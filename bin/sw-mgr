#!/bin/bash

VERSION="sw-mgr v0.236.0 - 20130722"
help() {
    cat <<EOD
Usage: `basename $0` [OPTION]
   OPTIONS
   -------
   --autoconf|-a                      Auto config from DB, implies at least
                                      a release number and the install path
   --force|-f                         Force installation/removal
   --override-lock                    Override the locks in the caches
   --help|-h                          Display this help
   --debug                            Enable debug output
   --install|-i <release number>      Install the selected release
   --validate|-V <release number>     Install and test the selected release
   --update|-u                        Update the selected release
   --test <release number>            Test the selected release
   --remove|-r  <release number>      Remove the selected release
   --manage|-M  <release number>      Manage the selected release
   --kit-cache|-k <URL>               Use URL as cache to download the kit
   --dbrelease <dbrel version>        Install the <dbrel version> DB release
   --dbrelease-clean                  Cleanup the DBReleases except the older
                                      and newer version installed
   --ddm-setup <path>                 Full path to the DDM setup file
   --ddm-site <sitename>              DDM site name
   --ddm-verify                       Verify downloaded files
   --goc-name <GOC site name>         GOC site name
   --cleanup|-C                       Delete the destination dirs
   --clean-links                      Cleanup the logical and physical link paths
   --check                            Executes the pre-install checks
   --cache                            Cache installation files in snapshots
   --cvmfs-install                    Force installation on cvmfs (for cvmfs deployment)
   --add-tags                         Add one or more tags
   --dump-tags <file>                 Dump the tags in <file>
   --force-tags                       Force the publishing of the tags
   --install-compiler                 Install the compiler
   --extra-tag                        Use an extra, unique tag suffix
   --tag-file <filename>              Use <filename> to store the tags
                                      (only for OSG or "file" tag utility)
   --tag-mode <grid|file>             Use grid or file tagging
   --tag-utility <name>               Use <name> tag utility
   --extra-pkg <pkg>                  Install the extra package <pkg>
   --disk-free <PHYS>:<LOG>           Requires at least <PHYS> kB free
                                      in the physical install area and
                                      <LOG> kB free in the logical
                                      install area (default: $MINDF)
   --min-install-size <size in kB>    minimum installation size in kB
                                      (default: $MININSTALLSIZE)
   --grid-name|-G <grid name>         Declare that you are using the
                                      <grid name> grid (default: $GRIDNAME)
   --host|-H <hostname>               Use <hostname> for tagging activities
   --subcluster <subcluster name>     Use <subcluster name> for tagging activities,
                                      will use the value supplied to --host
                                      if the name is the same
   --restore-backup                   Restore all backup files when removing a release
   --reinstall                        Reinstall the selected release
   --reinstall-clean                  Clean the old install when reinstalling
   --no-tag                           Don't manage tags after testing
   --no-opt                           Don't use the optimization tag
   --no-compat-patch                  Exclude compatibility patches
   --no-new-pacball                   Inhibit new pacball creation
   --post-siteinfo                    Post site info to $POSTSITEURL
   --post-siteurl <URL>               Use <URL> to post the site info
   --pacball                          Use pacballs instead of snapshots
   --pacball-repo <URL>               Web repository for the pacballs
                                      (default: $PACBALLREPO)
   --poolcond-copy                    Copy the PoolCat xml files from the latest release
   --poolcond-mode <mode>             Use "all" (default) to get the files and generate
                                      the PFC, "get" to get the files, only,
                                      and "gen" to generate the PFC only
   --poolcond-scandir                 Scan the PC top dir for subdirs to create the PFC
   --poolcond-topdir <path>           Top directory to store the poolcond files
   --poolcond-pattern <path>          Dataset patterns to generate the poolcond PFC
   --remove-tags                      Remove one or more tags
   --rm-tags-on-fail                  Remove one or more tags on validation failure
   --remove-snap|-R <release number>  Remove the snapshot for <release number>
   --replicate                        Replicate the installation files
   --require-compiler                 Require that the release compiler is present
   --require-shfs|-S                  Require that the install area is a shared fs
   --require-prj <project name>       Require <project name> to be installed
   --dest <path>                      Install the release in <path>
   --skip-local-config                Skip the local configuration setup
   --local-config <path>              Use <path> to store the local configuration files
   --logical|-l <path>                Install or manage the main logical release from <path>
   --logical-link <path>              Link the logical area from <path>, if present,
                                      or link it to <path>
   --package <package name>           Use the package <package name>
   --pacman-ver|-m <version>          Use pacman <version>
   --pretend-platform <platform>      Force pacman to assume using <platform>
   --no-cache|-n                      Don't create a snapshot for this release
   --no-version                       Don't use the version when getting packages
   --use-grid                         Use the Grid SEs to hold the snapshots
   --relative-links                   Make relative links
   --release-only|-o                  Pack only the release, no compiler or KV
   --release-path                     Path to the main release
   --physical <path>|-p               Install or manage the main physical release from <path>
   --physical-link <path>             Link the physical area from <path>, if present,
                                      or link it to <path>
   --project <project name>|-P        Use project <project name>
   --project-type <type>|-T           Use project type <type>
                                      <type> = release   -> production releases
                                      <type> = bugfix    -> bugfix nightlies
                                      <type> = dev       -> dev nightlies
                                      <type> = p1nightly -> point1 nightlies
                                      <type> = patch     -> production patches
                                      <type> = p1patch   -> point1 patches
                                      <type> = t0patch   -> Tier0 patches
                                      <type> = eventview -> PAT/EventView patches
                                      <type> = tdaq      -> TDAQ releases
   --project-opt <option>|-O          Use optimization <option>
                                      <option> = opt -> optimized mode
                                      <option> = dbg -> debug mode
   --site-config <path>               Use <path> to store the site configuration
   --site-type <type>                 Specify the site type (analysis, production, ...)
   --snap|-s <release number>         Create a snapshot for the selected release
   --snapname <snapshot name>         Use <snapshot name> for the snapshot
                                      file name
   --snapdir <path>                   Create the snapshots in <path>
   --create-dvd|-c                    Create a DVD image with the local releases
   --write-dvd|-w <image name>        Create the DVD image <image name>
   --dir|-d <installation directory>  Use <installation directory>
                                      for the installation
   --release-ver|-v <release version> Set the release version (default: ${RELVER})
   --target|-t <arch>                 Use <arch> architecture for installing
   --tthreads <n>                     Use <n> test threads (default: ${TESTTHR})
   --temp-cache                       Use a temporary cache to install
   --vo <VO name>                     VO name (default: ${TAGVO})
   --tags <TAG1,TAG2,TAG3,...>        Tag names, separated by commas
   --query|-q                         Query the available (local) releases
   --quiet|-Q                         Disable verbose output
   --xml|-x <file name>               Generate an XML report of the installation
   --kvpost                           Post the test results to the GKV portal
   --kv-cache <cache>                 Use the <cache> KitValidation cache
   --kv-conf <URL>                    Use <URL> to get the KV configuration
   --kv-disable <testlist>            Disable the selected KV tests
   --kv-enable <testlist>             Enable the selected KV tests
   --kv-keep                          Keep the test results
   --kv-no-auto                       Disable the KV automatic tests
   --kvpost-tag <tag>                 Use <tag> when posting to GKV
   --release-setup <path>             Setup from the most recent release <path>
   --release-setup-level <num>        Descend up to <num> levels to setup
                                      the releases (current: $MAXRELSETUPDEPTH)
                                      when required
   --setup-latest <path>              Setup the latest release from <path>
                                      at the beginning of the task
   --setenv <v1=val,v2=val,...>       Set the value of v1=val, v2=val, ...
                                      in the installation setup scripts
   --set-frontier                     Set the FRONTIER_SERVER in AtlasSite,
                                      if \$ATLAS_FRONTIER_CONF is found
   --stagein <URL>                    Download <URL> to the local working dir.
                                      <URL> can be a comma separated list of values.
   --validation-exe <file>            Use <file> to validate the installation

$VERSION
Alessandro De Salvo <Alessandro.DeSalvo@roma1.infn.it>
EOD
}


msgOut() {
   MSGTYPE="$1"
   MSGTEXT="$2"
   MSGDATE="`date +"%Y-%m-%d %H:%M:%S"`"
   [ "$QUIET" == "" ] && echo "[$MSGDATE] SWMGR> ${MSGTYPE}: ${MSGTEXT}"
   [ "$XMLFILE" != "" ] && xml add "    <swmgr type=\"$MSGTYPE\" datetime=\"$MSGDATE\">${MSGTEXT}</swmgr>"
   sync
   return 0
}


xml() {
   XMLCMD="${1}"
   XMLSTR="${2}"
   if [ "$XMLFILE" != "" ] ; then
       if [ "$XMLCMD" == "add" ] ; then
           echo $XMLSTR >> $XMLFILE
       fi
       if [ "$XMLCMD" == "open" ] ; then
           echo "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>" > $XMLFILE
           echo "<install>" >> $XMLFILE
       fi
       if [ "$XMLCMD" == "close" ] ; then
           echo "</install>" >> $XMLFILE
       fi
   fi
}

timeout () {
    perl -e 'alarm shift; exec @ARGV' "$@";
}

getFSType() {
    MOUNTPOINT="${1}"
    MOUNTPOINTFS="`df -T -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1 | awk '{print $2}'`"
    if [ "$MOUNTPOINTFS" == "fuse" ] ; then
      MOUNTPOINTFS="`df -T -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1 | awk '{print $1}' | cut -d# -f 1`"
    fi
    # Consider all mount starting with /cvmfs as CVMFS
    #[ -z "$MOUNTPOINTFS" -a "`echo $MOUNTPOINT | sed 's#/\([^/]*\)/.*#\1#'`" == "cvmfs" ] && MOUNTPOINTFS="cvmfs"
    [ "`echo $MOUNTPOINT | sed 's#/\([^/]*\)/*.*#\1#'`" == "cvmfs" ] && MOUNTPOINTFS="cvmfs"
    # Change cvmfs* to cvmfs
    MOUNTPOINTFS="`echo $MOUNTPOINTFS | sed 's/^cvmfs.*/cvmfs/'`"
    # Special mountpoint FS to allow deployment in cvmfs
    [ "$CVMFSINSTALL" == "yes" ] && MOUNTPOINTFS="cvmfsinstall"
    echo $MOUNTPOINTFS
    return 0
}

getDiskFree() {
    MOUNTPOINT="${1}"
    MOUNTPOINTFS="`getFSType ${MOUNTPOINT}`"
    # Temporary hack for bad sites
    SKIPDOMAIN="lrz-muenchen.de grid.lrz-muenchen.de"
    skip=0
    if [ "$TAGHOST" != "" ] ; then
        for item in $SKIPDOMAIN ; do
            [ "$item" == "`echo $TAGHOST | cut -d '.' -f 2-`" ] && skip=1
        done
    fi
    # Get the available space
    if [ $skip -eq 0 ] ; then
        if [ "$MOUNTPOINTFS" == "afs" ] ; then
            MOUNTPOINTDF="`fs listquota ${MOUNTPOINT} | tail -n 1 | awk '{print $2-$3}'`"
        else
            MOUNTPOINTDF="`df -k -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1 | awk '{print $4}'`"
        fi
    else
        # Return an high value for bad sites
        MOUNTPOINTDF=20000000
    fi
    [ "$MOUNTPOINTDF" == "" ] && MOUNTPOINTDF=0
    echo $MOUNTPOINTDF
    return 0
}

isSharedFS() {
    MOUNTPOINT="${1}"
    FSTYPE="`getFSType ${MOUNTPOINT}`"
    [ "$FSTYPE" == "afs" -o "$FSTYPE" == "nfs" -o "$FSTYPE" == "nfs4" -o "$FSTYPE" == "gpfs" -o "$FSTYPE" == "panfs" -o "$FSTYPE" == "lustre" -o "$FSTYPE" == "glusterfs" -o "$FSTYPE" == "cvmfs" -o "$FSTYPE" == "cvmfsinstall" -o "$FSTYPE" == "none" -o "$FSTYPE" == "-" ] && echo "yes" || echo "no"
}

swareaInfo() {
    MOUNTPOINT="${1}"
    MPINFO="`df -T -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1`"
    MPAREA="`echo ${MPINFO} | awk '{print $1}'`"
    # Quick fix for AFS
    #[ "$MPAREA" == "AFS" ] && MPAREA="$MOUNTPOINT"
    MPFS="`echo ${MPINFO} | awk '{print $2}'`"
    if [ "$MPFS" == "fuse" ] ; then
      MPFS="`df -T -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1 | awk '{print $1}' | cut -d# -f 1`"
    fi
    # Consider all mount starting with /cvmfs as CVMFS
    [ "`echo $MOUNTPOINT | sed 's#/\([^/]*\)/*.*#\1#'`" == "cvmfs" ] && MPFS="cvmfs"
    # Change cvmfs* to cvmfs
    MPFS="`echo $MPFS | sed 's/^cvmfs.*/cvmfs/'`"
    # Special mountpoint FS to allow deployment in cvmfs
    [ "$CVMFSINSTALL" == "yes" ] && MPFS="cvmfsinstall"
    MPAVAIL="`echo ${MPINFO} | awk '{print $4}'`"
    MPCAPACITY="`echo ${MPINFO} | awk '{print $5}'`"
    MPMP="`echo ${MPINFO} | awk '{print $7}'`"
    echo "swarea=${MPAREA}&fstype=${MPFS}&mountpoint=${MPMP}&capacity=${MPCAPACITY}&available=${MPAVAIL}"
    return 0
}

getSWarea() {
    MOUNTPOINT="${1}"
    MPINFO="`df -T -P ${MOUNTPOINT} 2>/dev/null | grep -v ^Filesystem | tail -n 1`"
    MPAREA="`echo ${MPINFO} | awk '{print $1}'`"
    echo "${MPAREA}"
    return 0
}

showSiteInfo() {
    msgOut INFO "======================="
    msgOut INFO "Resource info"
    msgOut INFO "Timestamp:  `date`"
    msgOut INFO "Running as: `whoami`"
    msgOut INFO "            `id`"
    msgOut INFO "Running on: `uname -a`"
    [ -n "$SHELL" ] && msgOut INFO "Shell:      $SHELL"
    [ "`which lsb_release 2> /dev/null`" != "" ] && msgOut INFO "`lsb_release -d`"
    msgOut INFO "======================="
}

hostEquiv() {
    if [ -n "`which lsb_release 2> /dev/null`" ] ; then
        LSBDESC="`lsb_release -sd | sed 's/"//g'`"
        LSBVER="`lsb_release -sr | sed 's/"//g' | cut -d. -f 1`"
        case $LSBDESC in
            Scientific\ Linux*) echo "host-slc$LSBVER"
                ;;
            Red\ Hat\ Enterprise*) echo "host-slc$LSBVER"
                ;;
            CentOS*) echo "host-slc$LSBVER"
                ;;
        esac
    fi
}

isInstalled() {
    # Check if ${ATLASRELEASE} is installed, using pacman
    iires=0
    if [ "`which pacman 2>/dev/null`" != "" ] ; then
        cd ${RELLOC}
        INSTPKG="`pacman -l ${ATLASRELEASE} | grep "^\[\*\].*${ATLASRELEASE}" | awk '{print $2}'`"
        [ "$INSTPKG" == "$ATLASRELEASE" ] && iires=1
    else
        iires=2
    fi
    return $iires
}

isAFSpath() {
    [ "`echo $1 | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] && echo "yes"
    return 0
}

getROpath() {
    RWPATH="$1"
    # Check if we are running in AFS
    if [ "`isAFSpath $RWPATH`" == "yes" ] ; then
        echo $RWPATH | sed 's#^/afs/\.*\(.*\)#/afs/\1#g'
    else
        echo $RWPATH
    fi
    return 0
}

getRWpath() {
    ROPATH="$1"
    # Check if we are running in AFS
    if [ "`isAFSpath $ROPATH`" == "yes" ] ; then
        # Check if we are already in the rw path 
        if [ "`echo $ROPATH | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
            echo $ROPATH | sed 's#^/afs/\(.*\)#/afs/.\1#g'
            return 0
        fi
    fi
    echo $ROPATH
    return 0
}

isAFSmountpoint() {
    fs lsmount $1
    return $?
}

findAFSmount() {
    AFSDIR="$1"
    while [ 1 ] ; do
        MP="`fs lsmount $AFSDIR 2>/dev/null`"
        if [ $? -eq 0 ] ; then
            echo $AFSDIR
            return 0
        else
            AFSDIR="`dirname $AFSDIR`"
        fi
        [ "$AFSDIR" == "/" -o "$AFSDIR" == "." ] && return 1
    done
}

checkSite() {
    msgOut INFO "Site checks started on `date`"
    let checkrc=0
    RELSHAREDFS="`isSharedFS $RELLOC`"
    RELDF="`getDiskFree ${RELLOC}`"
    isInstalled
    ISINSTALLED=$?
    if [ $ISINSTALLED -eq 0 -a "`getFSType $RELLOC`" != "cvmfs" ] ; then
        if [ "$RELDF" == "" -o $RELDF -lt $MINRELDF ] ; then
            msgOut ERROR "You don't have enough space in $RELLOC (actual=$RELDF, min=$MINRELDF)"
            let checkrc=100
        fi
    else
        msgOut INFO "The software you are installing is already present, ignoring the free space requirements for $RELLOC (actual=$RELDF, min=$MINRELDF)"
    fi
    if [ "$RELSHAREDFS" == "no" -a "$REQSHAREDFS" == "yes" ] ; then
        msgOut ERROR "The directory $RELLOC is not in a shared filesystem"
        msgOut INFO "[FS INFO] `df -T -P ${RELLOC} 2>/dev/null | grep -v ^Filesystem | tail -n 1`"
        let checkrc=110
    fi
    if [ "$PRJTYPE" != "patch" -a "$PRJTYPE" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "$PRJTYPE" != "eventview" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" ] ; then
        SWSHAREDFS="`isSharedFS $SWLOC`"
        SWDF="`getDiskFree ${SWLOC}`"
        if [ $ISINSTALLED -eq 0 -a "`getFSType $RELLOC`" != "cvmfs" ] ; then
            if [ "$SWDF" == "" -o $SWDF -lt $MINSWDF ] ; then
                msgOut ERROR "You don't have enough space in $SWLOC (actual=$SWDF, min=$MINSWDF)"
                let checkrc=100
            fi
        else
            msgOut INFO "The software you are installing is already present, ignoring the free space requirements for $SWLOC (actual=$SWDF, min=$MINSWDF)"
        fi
        if [ "$SWSHAREDFS" == "no" -a "$REQSHAREDFS" == "yes" ] ; then
            msgOut ERROR "The directory $SWLOC is not in a shared filesystem"
            msgOut INFO "[FS INFO] `df -T -P ${SWLOC} 2>/dev/null | grep -v ^Filesystem | tail -n 1`"
            let checkrc=110
        fi
    fi
    TDSHAREDFS="`isSharedFS $TOPDIR`"
    TDDF="`getDiskFree ${TOPDIR}`"
    if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
        msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
        TOPDIR=/tmp/tmp.atlas.install.$$
        TDDF="`getDiskFree /tmp`"
        SNAPDIR="${TOPDIR}/`basename ${SNAPDIR}`"
        msgOut INFO  "Trying to use ${TOPDIR}..."
        if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
            msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
            if [ "$VO_ATLAS_SW_DIR" != "" ] ; then
                TOPDIR=$VO_ATLAS_SW_DIR/tmp.atlas.install.$$
                TDDF="`getDiskFree ${VO_ATLAS_SW_DIR}`"
                SNAPDIR="${TOPDIR}/`basename ${SNAPDIR}`"
                msgOut INFO  "Trying to use ${TOPDIR}..."
                if [ "$TDDF" == "" -o $TDDF -lt $MINTDDF ] ; then
                    msgOut ERROR "You don't have enough space in $TOPDIR (actual=$TDDF, min=$MINTDDF)"
                    let checkrc=100
                else
                    msgOut INFO  "${TOPDIR} disk free OK"
                fi
            else
                msgOut ERROR "You don't seem to have VO_ATLAS_SW_DIR set. Giving up."
                let checkrc=100
            fi
        else
            msgOut INFO  "${TOPDIR} disk free OK"
        fi
    fi
    if [ ! -d ${TOPDIR} -a $checkrc -eq 0 ] ; then
        mkdir -p ${TOPDIR}
        \find $TOPDIR -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
        if [ $? -eq 0 ] ; then
            msgOut INFO  "Using ${TOPDIR} as temporary storage"
        else
            let checkrc=101
            msgOut ERROR "Cannot create the directory ${TOPDIR}"
        fi
    fi

    if [ $checkrc -eq 0 ] ; then
        msgOut INFO "Physical Area location:            $RELLOC"
        msgOut INFO "Physical Area details:             `\ls -ld $RELLOC`"
        [ "$SWLOC" != "$RELLOC" ] && \
        msgOut INFO "Logical Area location:             $SWLOC"
        msgOut INFO "Temporary Area location:           $TOPDIR"
        msgOut INFO "Available space in Physical Area:  $RELDF kB"
        [ "$SWLOC" != "$RELLOC" ] && \
        msgOut INFO "Available space in Logical Area:   $SWDF kB"
        msgOut INFO "Available space in Temporary Area: $TDDF kB"
        msgOut INFO "System pre-checks OK"
    else
        msgOut INFO "System pre-checks FAILED"
    fi
    if [ "$POSTSITEINFO" == "yes" -a "$TAGHOST" != "" ] ; then
        postSiteInfo
    fi

    return $checkrc
}


osinfo() {
    if [ -s /cvmfs/atlas.cern.ch/repo/sw/python/latest/setup.sh ] ; then
        (. /cvmfs/atlas.cern.ch/repo/sw/python/latest/setup.sh && python -c 'import platform,urllib; d,v,r=platform.linux_distribution(); print "osname=%s&osver=%s&osrel=%s" % (urllib.quote(d),urllib.quote(v),urllib.quote(r))')
    else
        echo "osname=&osver=&osrel="
    fi
}

postSiteInfo() {
    SWAREAINFO="`swareaInfo $RELLOC`"
    OSINFO="`osinfo`"
    curl --connect-timeout 300 --insecure -s -S --data "cename=${TAGHOST}&${SWAREAINFO}&$OSINFO" ${POSTSITEURL}
    psirc=$?
    if [ $psirc -eq 0 ] ; then
        msgOut INFO "Site info posted successfully: cename=${TAGHOST}&${SWAREAINFO}&$OSINFO"
    else
        msgOut INFO "Failed to post site info: cename=${TAGHOST}&${SWAREAINFO}&$OSINFO ${POSTSITEURL}"
    fi
    return $psirc
}


getCloseReplica() {
    SOURCE="${1}"
    LCG_LR="`which lcg-lr 2>/dev/null`"
    if [ "$LCG_LR" != "" ] ; then
        $LCG_LR --vo $TAGVO ${SOURCE} 2>/dev/null | grep ${CLOSESE} | tail -n 1
    fi
}


getGridFile() {
    DEFSOURCE="lfn:${1}"
    SOURCE="${DEFSOURCE}"
    REPDEST="install/lcg/`basename ${1}`"
    DEST="file:${2}"
    LCG_CP="`which lcg-cp 2>/dev/null`"
    LCG_LR="`which lcg-lr 2>/dev/null`"
    LCG_LG="`which lcg-lg 2>/dev/null`"
    LCG_REP="`which lcg-rep 2>/dev/null`"
    CMD_TIMEOUT=1800
    GUID=""
    let getrc=0
    if [ "$LCG_LG" != "" ] ; then
        GUID="`timeout $CMD_TIMEOUT $LCG_LG --vo $TAGVO ${SOURCE} 2>/dev/null`"
        if [ "$GUID" == "" ] ; then
            msgOut INFO "${SOURCE} not found in the Grid"
            let getrc=80
        else
            msgOut INFO "${SOURCE} OK"
            if [ "$CLOSESE" != "" ] ; then
                if [ "$LCG_LR" != "" ] ; then
                    CLOSE_REPLICA="`getCloseReplica ${SOURCE}`"
                    if [ "$CLOSE_REPLICA" != "" ] ; then
                        SOURCE="$CLOSE_REPLICA"
                    else
                        if [ "$GRIDREPLICA" == "yes" ] ; then
                            if [ "$LCG_REP" != "" ] ; then
                                msgOut INFO "Replicating installation files"
                                msgOut INFO "timeout $CMD_TIMEOUT $LCG_REP --vo ${TAGVO} -d ${CLOSESE} -P ${REPDEST} ${SOURCE}"
                                timeout $CMD_TIMEOUT $LCG_REP --vo ${TAGVO} -d ${CLOSESE} -P ${REPDEST} ${SOURCE}
                                [ $? -ne 0 ] && msgOut WARNING "Replication failed"
                                CLOSE_REPLICA="`getCloseReplica ${SOURCE}`"
                                [ "$CLOSE_REPLICA" != "" ] && SOURCE="$CLOSE_REPLICA"
                            else
                                msgOut WARNING "lcg-rep not found"
                                let getrc=70
                            fi
                        fi
                    fi
                else
                    msgOut WARNING "lcg-lr not found"
                    let getrc=70
                fi
            fi
            if [ "$LCG_CP" != "" ] ; then
                msgOut INFO  "Copying the file using ${SOURCE}"
                msgOut INFO  "Destination is ${DEST}"
                msgOut INFO  "LCG_GFAL_INFOSYS=${LCG_GFAL_INFOSYS}"
                msgOut INFO  "LFC_HOST=${LFC_HOST}"
                LCG_CP_VER="`$LCG_CP --version 2>/dev/null | grep ^lcg_util | cut -d'-' -f 2 | awk -F'.' '{for (i=1;i<=NF;i++) printf "%02d",$i;}'`"
                if [ $LCG_CP_VER -le 10600 ] ; then
                    LCG_CP_TIMEOUT="-t 1800"
                else
                    LCG_CP_TIMEOUT="--connect-timeout 1800 --sendreceive-timeout 1800 --bdii-timeout 300 --srm-timeout 1000"
                fi
                msgOut INFO "timeout $CMD_TIMEOUT $LCG_CP $LCG_CP_TIMEOUT --vo ${TAGVO} ${SOURCE} ${DEST}"
                timeout $CMD_TIMEOUT $LCG_CP $LCG_CP_TIMEOUT --vo ${TAGVO} ${SOURCE} ${DEST}
                if [ $? -ne 0 ] ; then
                    msgOut WARNING "Cannot get the file from the grid using ${SOURCE}"
                    msgOut INFO "Trying using ${DEFSOURCE}"
                    msgOut INFO "timeout $CMD_TIMEOUT $LCG_CP $LCG_CP_TIMEOUT --vo ${TAGVO} ${DEFSOURCE} ${DEST}"
                    timeout $CMD_TIMEOUT $LCG_CP $LCG_CP_TIMEOUT --vo ${TAGVO} ${DEFSOURCE} ${DEST}
                    if [ $? -ne 0 ] ; then
                        msgOut WARNING "Cannot get the file from the grid using ${DEFSOURCE}"
                        let getrc=80
                    fi
                else
                    msgOut INFO  "Copy OK"
                fi
            else
                msgOut WARNING "lcg-cp not found"
                let getrc=70
            fi
        fi
    else
        msgOut WARNING "lcg-lg not found"
        let getrc=70
    fi
    return $getrc
}

putGridFile() {
    SOURCE="${1}"
    LFN="${2}"
    DESTPATH="install/lcg/`basename $SOURCE`"
    LCG_LG="`which lcg-lg`"
    LCG_CR="`which lcg-cr`"
    GUID=""
    putrc=0
    if [ "$LCG_LG" != "" ] ; then
        GUID="`lcg-lg --vo ${TAGVO} lfn:${LFN} 2>/dev/null`"
        if [ "$GUID" != "" ] ; then
            msgOut WARNING "${LFN} already present in the Grid"
            putrc=90
        fi
    fi
    if [ $putrc -eq 0 ] ; then
        if [ "$LCG_CR" != "" ] ; then
            msgOut INFO "Registering ${SOURCE} in the Grid"
            msgOut INFO "Using LFN ${LFN}"
            [ "$CLOSESE" != "" ] && CLOSESE_OPT="-d $CLOSESE"
            msgOut INFO "CMD: lcg-cr --vo ${TAGVO} -l ${LFN} -P ${DESTPATH} file:${SOURCE} ${CLOSESE_OPT}"
            lcg-cr --vo ${TAGVO} -l ${LFN} -P ${DESTPATH} file:${SOURCE} ${CLOSESE_OPT}
            putrc=$?
            [ $putrc -ne 0 ] && msgOut WARNING "Registration failed"
        else
            msgOut WARNING "lcg-cr not found"
            putrc=70
        fi
    fi
    return $putrc
}

getDDMFile() {
    PBDATASET="${1}"
    PBNAME="${2}"
    CMD_TIMEOUT=600
    GUID=""
    let getrc=0

    # Setup the DDM
    if [ -n "$DDMSETUP" -a -n "$OSG_APP" -a -s "$OSG_APP/atlas_app/atlaswn/setup.sh" ] ; then
        DDMSETUP="$OSG_APP/atlas_app/atlaswn/setup.sh"
        msgOut INFO "Overriding the DDM location with $DDMSETUP"
    fi
    if [ "$DDMSETUP" != "" -a -s "$DDMSETUP" ] ; then
        source $DDMSETUP
        if [ $? -eq 0 ] ; then
            [ -z "$DQ2_LOCAL_SITE_ID" ] && export DQ2_LOCAL_SITE_ID="ROAMING"
            msgOut INFO "DDM configured from $DDMSETUP"
            msgOut INFO "Using DQ2_LOCAL_SITE_ID=$DQ2_LOCAL_SITE_ID"
            msgOut INFO "`voms-proxy-info -all`"
        else
            msgOut ERROR "Cannot configure DDM from $DDMSETUP"
        fi
    else
        [ "$DDMSETUP" != "" ] && msgOut ERROR "No DDM setup file found in $DDMSETUP"
    fi

    # Start the installation
    DQ2GET="`which dq2-get 2>/dev/null`"
    if [ -n "$DQ2GET" ] ; then
        $DQ2GET -H $PWD -f ${PBNAME} ${PBDATASET}
        let getrc=$?
        if [ ! -s ${PBNAME} ] ; then
            msgOut ERROR "Cannot get file $PBNAME from dataset $PBDATASET"
            let getrc=$getrc+10
        fi
    else
        msgOut WARNING "dq2-get not found"
        let getrc=70
    fi
    return $getrc
}

setupDev() {
    SETUP_OPT="${1}"
    LASTCWD=$PWD
    REQFILE=$PWD/cmthome/requirements
    TESTAREA=$PWD/testarea
    msgOut INFO "Creating requirements file ${REQFILE}"
    [ ! -d "`dirname ${REQFILE}`" ] && mkdir -p "`dirname ${REQFILE}`"
    [ ! -d "${TESTAREA}" ] && mkdir -p "${TESTAREA}"
    rm -f ${REQFILE}
    cat > ${REQFILE} <<EORF
set CMTSITE ${CMTSITE}
set SITEROOT ${SITEROOT}
macro ATLAS_DIST_AREA ${SITEROOT}
apply_tag projectArea
macro SITE_PROJECT_AREA ${SITEROOT}
macro EXTERNAL_PROJECT_AREA ${SITEROOT}
apply_tag setup
apply_tag simpleTest
macro ATLAS_TEST_AREA ${TESTAREA}
EORF

    if [ "$PRJTYPE" == "eventview" ] ; then
        cat >> ${REQFILE} <<EORF
macro ATLAS_GROUP_AREA "`dirname ${SWPHYS}`"
EORF
    fi
    cat >> ${REQFILE} <<EORF
use AtlasLogin AtlasLogin-* \$(ATLAS_DIST_AREA)
set CMTCONFIG ${CMTCONFIG}
set DBRELEASE_INSTALLED  $DBRELEASE_INSTALLED
EORF
    crfrc=$?
    if [ $crfrc -eq 0 ] ; then
        msgOut INFO "`cat ${REQFILE}`"
        msgOut INFO "Configuring CMT"
        cd `dirname $REQFILE`
        cmt config
        let crfrc=$crfrc+$?
        if [ $crfrc -eq 0 ] ; then
            msgOut INFO "CMT configuration successful"
            msgOut INFO "Setting up the release from $PWD"
            msgOut INFO "source setup.sh $SETUP_OPT"
            source setup.sh $SETUP_OPT
            msgOut INFO "GroupArea=$GroupArea"
            msgOut INFO "JOBOPTSEARCHPATH=$JOBOPTSEARCHPATH"
        else
            msgOut ERROR "Error during CMT configuration"
        fi
        cd $LASTCWD
    else
        msgOut ERROR "Cannot create ${REQFILE}"
    fi
    return $crfrc
}

setCompiler() {
    COMP_PATH="`getROpath ${1}`"
    SITECONF="`getRWpath ${SITECONF}`"
    # Set the compiler hooks in the Site Configuration
    if [ -s "$SITECONF" ] ; then
        COMPILER_PATH="`cat $SITECONF | grep -v ^# | grep gcc${ARCH} | tail -n 1 | cut -d= -f 2`"
    fi
    if [ "$COMPILER_PATH" == "" -o "$COMPILER_PATH" != "${COMP_PATH}" ] ; then
        if [ -s "$SITECONF" ] ; then
            mv -f "$SITECONF" "${SITECONF}.orig"
            cat "${SITECONF}.orig" | grep -v "gcc${ARCH}=" > "$SITECONF"
        fi
        msgOut INFO "Adding gcc${ARCH}=${COMP_PATH} to $SITECONF"
        echo "gcc${ARCH}=${COMP_PATH}" >> $SITECONF
    else
        msgOut INFO "Compiler setup already present in $SITECONF for gcc${ARCH} ($COMPILER_PATH)"
    fi
    return 0
}

unsetCompiler() {
    SITECONF="`getRWpath ${SITECONF}`"
    # Unset the compiler hooks in the Site Configuration
    if [ -s "$SITECONF" ] ; then
        COMPILER_PATH="`cat $SITECONF | grep -v ^# | grep gcc${ARCH} | tail -n 1 | cut -d= -f 2`"
        if [ "$COMPILER_PATH"  != "" ] ; then
            msgOut INFO "Removing gcc${ARCH} from $SITECONF"
            mv -f "$SITECONF" "${SITECONF}.orig"
            cat "${SITECONF}.orig" | grep -v "gcc${ARCH}=" > "$SITECONF"
            [ ! -s "$SITECONF" ] && rm -f "$SITECONF"
        fi
    fi
    return 0
}

filerotate() {
    frrc=0
    FROTATE="$1"
    FCOPIES=$2
    FINCR=$((-$3))
    if [ $FINCR -lt 0 ] ; then
        FFIRST=$FCOPIES
        FLAST=0
    else
        FFIRST=0
        FLAST=$FCOPIES
    fi
    for indx in `seq $FFIRST $FINCR $FLAST` ; do
        FNEXT=$((indx-FINCR))
        currfrrc=0
        if [ -f ${FROTATE}.${indx} ] ; then
            if [ $FNEXT -gt $FCOPIES ] ; then
                rm -f ${FROTATE}.${indx}
                currfrrc=$?
                [ $currfrrc -ne 0 ] && msgOut WARNING "Cannot remove ${FROTATE}.${indx}"
            elif [ $FNEXT -eq 0 ] ; then
                mv -f ${FROTATE}.${indx} ${FROTATE}
                currfrrc=$?
                [ $currfrrc -ne 0 ] && msgOut WARNING "Cannot mv ${FROTATE}.${indx} to ${FROTATE}"
            else
                mv -f ${FROTATE}.${indx} ${FROTATE}.${FNEXT}
                currfrrc=$?
                [ $currfrrc -ne 0 ] && msgOut WARNING "Cannot mv ${FROTATE}.${indx} to ${FROTATE}.${FNEXT}"
            fi
        elif [ ${indx} -eq 0 -a -f ${FROTATE} ] ; then
            if [ $FINCR -lt 0 ] ; then
                mv -f ${FROTATE} ${FROTATE}.1
                currfrrc=$?
                [ $currfrrc -ne 0 ] && msgOut WARNING "Cannot mv ${FROTATE} to ${FROTATE}.1"
            else
                if [ -f ${FROTATE}.1 ] ; then
                    mv -f ${FROTATE}.1 ${FROTATE}
                    currfrrc=$?
                    [ $currfrrc -ne 0 ] && msgOut WARNING "Cannot mv ${FROTATE}.1 to ${FROTATE}"
                fi
            fi
        fi
        let frrc=$frrc+$currfrrc
    done
    [ $frrc -ne 0 ] && msgOut WARNING "Cannot rotate ${FROTATE}"
    return $frrc
}

snap() {
    SNAPDIR="${1}"
    SNAPDIR_TMP="${SNAPDIR}.tmp.$$"
    SNAPNAME="${2}"
    SNAP="${SNAPDIR}/${SNAPNAME}"
    TAR_NAME=${SNAPNAME}.tar.gz
    NEW_SNAP="no"
    let snaprc=0

    # If the Grid caching is enabled try to get the file from a SE
    if [ "$USEGRID" == "yes" ] ; then
        mkdir -p "${SNAPDIR_TMP}"
        cd "${SNAPDIR_TMP}"
        getGridFile ${CATALOG_PATH}/${TAR_NAME} ${PWD}/${TAR_NAME}
        if [ -s $PWD/$TAR_NAME ] ; then
            msgOut INFO "Snapshot tarball copied to ${PWD}/${TAR_NAME}"
            msgOut INFO "`\ls -l ${PWD}/${TAR_NAME}`"
            tar xfz $TAR_NAME
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Failed to untar the snapshot tarball"
            else
                msgOut INFO "Snapshot tarball unpacked successfully"
                md5sum -c MD5SUM > /dev/null
                if [ $? -ne 0 ] ; then
                    msgOut ERROR "Checksum error in the snapshot files"
                else
                    msgOut INFO "Snapshot checksum OK"
                    rm -fr ${SNAP}*
                    SNAPSHOT="`\ls -d ${SNAPNAME}.snap* 2>/dev/null | tail -n 1`"
                    if [ "$SNAPSHOT" != "" ] ; then
                        [ ! -d "${SNAPDIR}" ] && mkdir -p "${SNAPDIR}"
                        mv ${SNAPSHOT} ${SNAPDIR}
                        msgOut INFO "Snapshot ${SNAPSHOT} moved to ${SNAPDIR}"
                        msgOut INFO "Listing contents of dir ${SNAPDIR}"
                        msgOut INFO "`\ls -l ${SNAPDIR} 2>/dev/null`"
                        msgOut INFO "Listing details of the snapshot"
                        msgOut INFO "`\du -sk -l ${SNAP}.snap* 2>/dev/null`"
                    else
                        msgOut ERROR "Cannot find the snapshot"
                    fi
                fi
            fi
        fi
        cd -
        rm -fr ${SNAPDIR_TMP}
    fi

    # Make the snapshot, if needed
    SNAPSHOT="`\ls -ld ${SNAP}.snap* 2>/dev/null | tail -n 1`"
    if [ "${SNAPSHOT}" == "" ] ; then
        msgOut INFO "Cannot find snapshot called ${SNAP}.snap*"
        msgOut INFO "Downloading and snapshotting"
        msgOut INFO "Snapshot name: `basename ${SNAP}`"
        NEW_SNAP="yes"
        if [ "$PACMAN_OPTS" != "" ] ; then
            pacman $PACMAN_OPTS
            if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
                pacman -v down tar up
            else
                pacman -v download tar up
            fi
            pacman -def
        fi
        TMPAREA="${TOPDIR}/tmp.$$"
        TMPDIR="/tmp/atlas-install-$PRJNAME-$RELEASE"
        mkdir -p "${TMPAREA}"
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot create ${TMPAREA}"
            return $snaprc
        fi
        ln -sf ${TMPAREA} ${TMPDIR}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot link ${TMPAREA} to ${TMPDIR}"
            return $snaprc
        fi
        let snaprc=$snaprc+$?
        cd "${TMPDIR}"
        if [ "$PACKOPT" == "all" ] ; then
            echo y | pacman $PACMAN_OPTS -fetch \
                     ${LCGCACHE}:${RELEASE}/${GCC}
            let snaprc=$snaprc+$?
            echo y | pacman $PACMAN_OPTS -fetch \
                     ${LCGCACHE}:${RELEASE}/${KV}
            let snaprc=$snaprc+$?
        fi
        echo "pacman $PACMAN_OPTS -fetch \"${ATLAS}:${ATLASRELEASE}\""
        echo y | pacman $PACMAN_OPTS -fetch "${ATLAS}:${ATLASRELEASE}"
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot fetch ${ATLAS}:${ATLASRELEASE}"
            return $snaprc
        fi
        if [ "$EXTRPKG" != "" ] ; then
            echo "pacman $PACMAN_OPTS -fetch ${ATLAS}:${EXTRAPKG}"
            echo y | pacman $PACMAN_OPTS -fetch ${ATLAS}:${EXTRAPKG}
            let snaprc=$snaprc+$?
            if [ $snaprc -ne 0 ] ; then
                msgOut ERROR "Cannot fetch ${ATLAS}:${EXTRAPKG}"
                return $snaprc
            fi
        fi
        [ ! -d "${SNAPDIR}" ] && mkdir -p "${SNAPDIR}"
        pacman -snap -o "${SNAP}" .
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot create the snapshot ${SNAP}"
            return $snaprc
        fi
        cd "${TOPDIR}"
        # Clean up the temporary directory and link
        rm -fr ${TMPDIR}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary link ${TMPDIR}"
            return $snaprc
        fi
        rm -fr ${TMPAREA}
        let snaprc=$snaprc+$?
        if [ $snaprc -ne 0 ] ; then
            msgOut ERROR "Cannot remove the temporary area ${TMPAREA}"
            return $snaprc
        fi

        # Register the tarball to the Grid, if required
        if [ "$USEGRID" == "yes" -a "$NEW_SNAP" == "yes" ] ; then
            cd "$SNAPDIR"
            # Checksums
            msgOut INFO "Calculating checksums"
            \find ${SNAPNAME}.* -type f -exec md5sum {} \; > MD5SUM
            let snaprc=$snaprc+$?
            # Create the tarball
            msgOut INFO "Creating the installation tarball"
            tar cfz ${TAR_NAME} ${SNAPNAME}.* MD5SUM
            let snaprc=$snaprc+$?
            if [ $snaprc -eq 0 ] ; then
                msgOut INFO "Registering the installation tarball to the Grid"
                putGridFile $PWD/${TAR_NAME} ${CATALOG_PATH}/${TAR_NAME}
            else
                msgOut ERROR "Cannot create ${TAR_NAME}"
            fi
            if [ -s "${TAR_NAME}" ] ; then
                msgOut INFO "Removing ${TAR_NAME}"
                rm -fr "${TAR_NAME}"
            fi
        fi
    else
        msgOut INFO "Snapshot found: ${SNAPSHOT}"
    fi
    msgOut INFO "Snapshot processing OK"
    return $snaprc
}

pacball() {
    PBDIR="${1}"
    PBDIR_TMP="${PWD}/pacballs.tmp.$$"
    PBNAME="${2}"
    TAR_NAME="${PBNAME}.tar.gz"
    PB="${PBDIR}/${PBNAME}"
    NEW_PB="no"
    let pbrc=0

    # Check if a pacball is available from TOPDIR and use it
    if [ -s "${TOPDIR}/${PBNAME}" -o -s "${INSTALLER_HOME}/${PBNAME}" ] ; then
        [ ! -d "${PBDIR}" ] && mkdir -p "${PBDIR}"
        if [ $? -ne 0 ] ; then
            msgOut ERROR "Cannot create ${PBDIR}"
            return 1
        fi
        if [ -s "${TOPDIR}/${PBNAME}" ] ; then
            msgOut INFO "Linking pacball from ${TOPDIR}/${PBNAME}"
            ln -sf "${TOPDIR}/${PBNAME}" "$PB"
        elif [ -s "${INSTALLER_HOME}/${PBNAME}" ] ; then
            msgOut INFO "Linking pacball from ${INSTALLER_HOME}/${PBNAME}"
            ln -sf "${INSTALLER_HOME}/${PBNAME}" "$PB"
        fi
    fi

    # Start the pacball processing
    if [ ! -s $PB ] ; then
        # Create a temporary directory ad use it for the pacball downloads or creation
        mkdir -p "${PBDIR_TMP}"
        if [ $? -ne 0 ] ; then
            msgOut ERROR "Cannot create ${PBDIR_TMP}"
            return 1
        fi
        cd "${PBDIR_TMP}"

        # If the DDM facility is available try to get the file from DQ2
        if [ -n "$DDMSETUP" -a -n "${PACBALLDATASET}" ] ; then
            rm -fr ${PBDIR_TMP}/*
            getDDMFile ${PACBALLDATASET} ${PBNAME}
            if [ -s $PWD/$PBNAME ] ; then
                msgOut INFO "Pacball copied to ${PWD}/${PBNAME}"
                msgOut INFO "`\ls -l ${PWD}/${PBNAME}`"
            else
                rm -f ${PWD}/${PBNAME}
            fi
        fi

        # If we failed to get the pacball via DDM or we didn't enable
        # the DDM retrieval try to get it via grid, if enabled
        PACBALL="`\ls -d ${PBNAME} 2>/dev/null | tail -n 1`"
        if [ "${PACBALL}" == "" -a "${USEGRID}" == "yes" ] ; then
            # If the Grid caching is enabled try to get the file from a SE
            rm -fr ${PBDIR_TMP}/*
            getGridFile ${CATALOG_PATH}/${PBNAME} ${PWD}/${PBNAME}
            if [ -s $PWD/$PBNAME ] ; then
                msgOut INFO "Pacball copied to ${PWD}/${PBNAME}"
                msgOut INFO "`\ls -l ${PWD}/${PBNAME}`"
            else
                rm -f ${PWD}/${PBNAME}
            fi
        fi

        # If we failed to get the pacball from the grid or we didn't enable
        # the grid retrieval and the pacball is not available,
        # try to get it from the web repository
        PACBALL="`\ls -d ${PBNAME} 2>/dev/null | tail -n 1`"
        if [ "${PACBALL}" == "" -a "${PACBALLREPO}" != "" ] ; then
            rm -fr ${PBDIR_TMP}/*
            msgOut INFO "Cannot find any pacball called ${PBNAME}"
            msgOut INFO "Trying to download it from ${PACBALLREPO}"
            wget -q ${PACBALLREPO}/${PBNAME}
            if [ $? -eq 0 -a -s $PWD/$PBNAME ] ; then
                msgOut INFO "Pacball downloaded to ${PWD}/${PBNAME}"
                msgOut INFO "`\ls -l ${PWD}/${PBNAME}`"
            else
                msgOut WARNING "Failed to download the pacball from ${PACBALLREPO}/${PBNAME}"
            fi
        fi

        # Make the pacball, if needed
        PACBALL="`\ls -d ${PBNAME} 2>/dev/null | tail -n 1`"
        if [ "${PACBALL}" == "" ] ; then
            msgOut INFO "Cannot find any pacball called ${PBNAME}"
            msgOut INFO "Listing current directory ($PWD):"
            msgOut INFO "`ls -l`"
            if [ "${CREATE_PACBALL}" != "n" ] ; then
                rm -fr ${PBDIR_TMP}/*
                msgOut INFO "Downloading and creating the pacball"
                rm -f `echo ${PBNAME} | cut -d. -f 1`.*.sh
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                NEW_PB="yes"
                if [ "$PACMAN_OPTS" != "" -a "$USEPACBALL" != "yes" ] ; then
                    pacman $PACMAN_OPTS
                    if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
                        pacman -v down tar up
                    else
                        pacman -v download tar up
                    fi
                    pacman -def
                fi
                TMPAREA="${PBDIR_TMP}/tmp.$$"
                TMPDIR="/tmp/atlas-install-$PRJNAME-$RELEASE"
                mkdir -p "${TMPAREA}"
                let pbrc=$pbrc+$?
                if [ $pbrc -ne 0 ] ; then
                    msgOut ERROR "Cannot create ${TMPAREA}"
                    return $pbrc
                fi
                ln -sf ${TMPAREA} ${TMPDIR}
                let pbrc=$pbrc+$?
                if [ $pbrc -ne 0 ] ; then
                    msgOut ERROR "Cannot link ${TMPAREA} to ${TMPDIR}"
                    rm -fr "${TMPAREA}"
                    return $pbrc
                fi
                let pbrc=$pbrc+$?
                cd "${TMPDIR}"
                PBPKG="`echo ${PBNAME} | cut -d'.' -f 1`"
                echo "pacman $PACMAN_OPTS -pacball ${ATLAS}:${PBPKG}"
                echo y | pacman $PACMAN_OPTS -pacball ${ATLAS}:${PBPKG}
                let pbrc=$pbrc+$?
                NEWPBNAME="`ls -d ${PBPKG}.*.sh 2>/dev/null`"
                if [ $pbrc -eq 0 -a -n "$NEWPBNAME" ] ; then
                    PBNAME=${NEWPBNAME}
                    SNAPNAME=${PBNAME}
                    mv ${PBNAME} ${PBDIR_TMP}/${PBNAME} 2> /dev/null
                    msgOut INFO "New pacball name: ${PBNAME}"
                else
                    msgOut ERROR "Cannot create the pacball ${PBPKG} from ${ATLAS}:${PBPKG}"
                fi
                cd "${PBDIR_TMP}"
                # Clean up the temporary directory and link
                rm -fr ${TMPDIR}
                let pbrc=$pbrc+$?
                [ $pbrc -ne 0 ] && msgOut ERROR "Cannot remove the temporary link ${TMPDIR}"
                rm -fr ${TMPAREA}
                let pbrc=$pbrc+$?
                [ $pbrc -ne 0 ] && msgOut ERROR "Cannot remove the temporary area ${TMPAREA}"

                # Register the tarball to the Grid, if required
                if [ "$USEGRID" == "yes" -a "$NEW_SNAP" == "yes" -a $pbrc -eq 0 ] ; then
                    if [ $pbrc -eq 0 ] ; then
                        msgOut INFO "Registering the pacball to the Grid"
                        putGridFile $PBDIR_TMP}/${PBNAME} ${CATALOG_PATH}/${PBNAME}
                    else
                        msgOut ERROR "Cannot register ${PBNAME} to the grid"
                    fi
                fi
            else
                msgOut INFO "Pacball creation has been disabled, will not create any new pacball."
            fi
        fi

        # Check if we  finally get a pacball
        cd "${PBDIR_TMP}"
        PACBALL="`\ls -d ${PBNAME} 2>/dev/null | tail -n 1`"
        if [ $pbrc -eq 0 -a "${PACBALL}" != "" ] ; then
            msgOut INFO "Pacball container found: ${PBNAME}"
            MD5SUM="`echo ${PBNAME} | sed 's/.*\.md5-\(.*\).sh/\1/g'`"
            echo "$MD5SUM  $PBNAME" > MD5SUM
            msgOut INFO "Checking the pacball integrity using md5"
            msgOut INFO "`/bin/cat MD5SUM`"
            md5sum -c MD5SUM > /dev/null
            let pbrc=$pbrc+$?
            if [ $pbrc -ne 0 ] ; then
                msgOut ERROR "Checksum error in the pacball file"
            else
                msgOut INFO "Pacball checksum OK"
                [ ! -d "${PBDIR}" ] && mkdir -p "${PBDIR}"
                rm -fr ${PBDIR}/${PBNAME}
                mv ${PBNAME} ${PBDIR}
                msgOut INFO "Pacball ${PBNAME} moved to ${PBDIR}"
                msgOut INFO "Listing contents of dir ${PBDIR}"
                msgOut INFO "`\ls -l ${PBDIR} 2>/dev/null`"
                msgOut INFO "Listing details of the pacball"
                msgOut INFO "`\du -sk -l ${PBDIR}/${PBNAME} 2>/dev/null`"
            fi
        fi
    else
        msgOut INFO "Pacball found in ${PB}"
    fi
    if [ $pbrc -eq 0 ] ; then
        msgOut INFO "Pacball processing OK"
    else
        msgOut INFO "Failed to process the pacball"
    fi
    cd "$TOPDIR"
    rm -fr "${PBDIR_TMP}"
    return $pbrc
}

OSGTags() {
    local TU_OPTS=`getopt -o adlL:prtV -l add,ce:,debug,file:,list,location:,project:,remove,sc:,tags:,vo:,version -- "$@"`
    if [ $? != 0 ] ; then echo "Terminating..."; return 1 ; fi
    eval set -- "$TU_OPTS"

    # Defaults
    local TU_CE=
    local TU_DEBUG="no"
    local TU_TFILE=
    local TU_LOCATION=
    local TU_MODE="list"
    local TU_PROJECT=
    local TU_TAGS=
    local TU_VER="OSGTags v0.4 - (c) Alessandro De Salvo <Alessandro.DeSalvo@roma1.infn.it> - 20100608"
    local TU_VO="atlas"
    local TU_RC=0

    while true ; do
        case "$1" in
            --add|-a)      TU_MODE="add";shift;;
            --debug|-d)    TU_DEBUG="yes";shift;;
            --ce)          TU_CE="$2";shift 2;;
            --file|-f)     TU_TFILE="$2";shift 2;;
            --list|-l)     TU_MODE="list";shift;;
            --location|-L) TU_LOCATION="$2";shift 2;;
            --project|-p)  TU_PROJECT="$2";shift 2;;
            --remove|-r)   TU_MODE="remove";shift;;
            --sc)          TU_CE="$2";shift 2;;
            --tags|-t)     TU_TAGS="$2";shift 2;;
            --vo)          TU_VO="$2";shift 2;;
            --version|-V)  echo $TU_VER;return 0;;
            --)            shift;break;;
            \?)            break;
            exit;;
        esac
    done

    # Check the CLI syntax
    if [ "$TU_TFILE" == "" ] ; then
        if [ "$OSG_APP" != "" ] ; then
            if [ ! -d "$OSG_APP/etc" ] ; then
                echo "Cannot find dir $OSG_APP/etc"
                return 1
            fi
            TU_TFILE="$OSG_APP/etc/grid3-locations.txt"
        else
            echo "No output file specified and OSG_APP not defined! Please use --file <output file>."
            return 1
        fi
    fi
    if [ "$TU_MODE" != "list" -a "$TU_TAGS" == "" ] ; then
        echo "No tags specified! Please use --tags <tag list>."
        return 2
    fi
    if [ "$TU_MODE" != "list" -a "$TU_LOCATION" == "" ] ; then
        echo "No location specified! Please use --location <path>."
        return 3
    fi
    if [ "$TU_MODE" != "list" -a "$TU_PROJECT" == "" ] ; then
        echo "No project specified! Please use --project <path>."
        return 4
    fi

    local TU_TAGLINE=""
    local TU_TAG=""

    # Perform the actions

    # Xin Zhao -- move the lock file to $OSG_APP/atlas_app/atlas_rel, 
    # since not all OSG sites allow write permission to the whole $OSG_APP/etc dir
    TU_LOCKDIR="`dirname ${RELLOC}`"
    TU_LOCKFILE=${TU_LOCKDIR}/`basename ${TU_TFILE}.lock`
    while [ ! -d $TU_LOCKDIR ] ; do TU_LOCKDIR="`dirname $TU_LOCKDIR`"; done
    TU_LOCKDIRFS="`getFSType $TU_LOCKDIR`"
    if [ "$TU_LOCKDIRFS" == "cvmfs" ] ; then
        if [ -n "$ATLAS_LOCAL_AREA" ] ; then
            TU_LOCKFILE="$ATLAS_LOCAL_AREA/`basename ${TU_TFILE}.lock`"
            echo "Using lockfile $TU_LOCKFILE"
        elif [ -n "$OSG_APP" -a -d "$OSG_APP/etc" ] ; then
            TU_LOCKFILE="$OSG_APP/etc/`basename ${TU_TFILE}.lock`"
            echo "No ATLAS_LOCAL_AREA defined. Will use $TU_LOCKFILE as lockfile"
        else
            TU_LOCKFILE="/tmp/`basename ${TU_TFILE}.lock`"
            echo "No suitable dir found for lockfiles. Using $TU_LOCKFILE"
        fi
    fi
    [ "$TU_DEBUG" == "yes" ] && echo "Using Lockfile $TU_LOCKFILE"
    
    if [ "$TU_MODE" == "add" ] ; then
        [ "$TU_DEBUG" == "yes" ] && echo "Adding tags ${TU_TAGS} to ${TU_TFILE}"
        if [ -f "${TU_LOCKFILE}" ] ; then
            echo "Lock file exists: ${TU_LOCKFILE}"
            waittime=0
            while `test -f ${TU_LOCKFILE}`; do
                sleep 10s
                let waittime=$waittime+1
                if [ $waittime -gt 7200 ] ; then
                    msgOut WARNING "Timeout [3600 s]"
                    msgOut WARNING "Removing stale tagging lock"
                    rm -f ${TU_LOCKFILE}
                    break
                fi
            done
            if [ -f "${TU_LOCKFILE}" ] ; then
                echo "Lock file still exists: ${TU_LOCKFILE}"
                echo "Aborting the tag operations"
                return 10
            fi
        fi
        if [ -f ${TU_TFILE} ] ; then
            \cp "${TU_TFILE}" "${TU_LOCKFILE}"
        else
            touch "${TU_LOCKFILE}"
        fi
        if [ $? -ne 0 ] ; then
            echo "Cannot create lock file ${TU_LOCKFILE}"
            echo "Aborting the tag operations"
            return 11
        else
            for TU_TAG in "`echo ${TU_TAGS} | sed 's/,/ /g'`"; do
                TU_TAGLINE="${TU_TAG} ${TU_PROJECT} ${TU_LOCATION}"
                #TU_FTAG="`grep "${TU_TAGLINE}" "${TU_TFILE}" 2>/dev/null`"
                TU_FTAG="`grep "^${TU_TAG}" "${TU_TFILE}" 2>/dev/null`"
                if [ "$TU_FTAG" == "" ] ; then
                    [ "$TU_DEBUG" == "yes" ] && echo "Adding tag ${TU_TAGLINE} to ${TU_TFILE}"
                    echo "${TU_TAGLINE}" >> "${TU_LOCKFILE}"
                    if [ $? -ne 0 ] ; then
                        echo "Cannot add new tags to file ${TU_LOCKFILE}"
                        echo "Aborting the tag operations"
                        rm -f "${TU_LOCKFILE}"
                        return 12
                    fi
                else
                    echo "The tag ${TU_TAGLINE} is already present in ${TU_TFILE}"
                fi
            done
            \cp "${TU_LOCKFILE}" "${TU_TFILE}"
            if [ $? -ne 0 ] ; then
                echo "Cannot finalize the update to file ${TU_TFILE}"
                echo "Aborting the tag operations"
                rm -f "${TU_LOCKFILE}"
                return 13
            fi 
            [ "$TU_DEBUG" == "yes" ] && echo "Tags added succesfully to ${TU_TFILE}"
        fi 
        rm -f "${TU_LOCKFILE}"
    elif [ "$TU_MODE" == "remove" ] ; then
        [ "$TU_DEBUG" == "yes" ] && echo "Removing tags ${TU_TAGS} from ${TU_TFILE}"
        if [ -f "${TU_LOCKFILE}" ] ; then
            echo "Lock file exists: ${TU_LOCKFILE}"
            waittime=0
            while `test -f ${TU_LOCKFILE}`; do
                sleep 1s
                let waittime=$waittime+1
                if [ $waittime -gt 3600 ] ; then
                    msgOut WARNING "Timeout [3600 s]"
                    msgOut WARNING "Removing stale tagging lock"
                    rm -f ${TU_LOCKFILE}
                    break
                fi
            done
            if [ -f "${TU_LOCKFILE}" ] ; then
                echo "Lock file still exists: ${TU_LOCKFILE}"
                echo "Aborting the tag operations"
                return 20
            fi
        fi
        local TU_FTAG=""
        [ ! -f "${TU_TFILE}" ] && touch "${TU_TFILE}"
        touch "${TU_LOCKFILE}"
        for TU_TAG in "`echo ${TU_TAGS} | sed 's/,/ /g'`"; do
            TU_TAGLINE="${TU_TAG} ${TU_PROJECT} ${TU_LOCATION}"
            TU_FTAG="`grep "${TU_TAG}" "${TU_TFILE}"`"
            if [ "$TU_FTAG" != "" ] ; then
                [ "$TU_DEBUG" == "yes" ] && echo "Removing tag ${TU_TAG} from ${TU_TFILE}"
                grep -v "${TU_TAG}" "${TU_TFILE}" > "${TU_LOCKFILE}"
                if [ $? -ne 0 -a `cat ${TU_TFILE} | wc -l` -gt 1 ] ; then
                    echo "Cannot create lock file ${TU_LOCKFILE} while removing tag ${TU_TAG}"
                    echo "Aborting the tag operations"
                    rm -f "${TU_LOCKFILE}"
                    return 21
                else
                    \cp "${TU_LOCKFILE}" "${TU_TFILE}"
                    if [ $? -ne 0 ] ; then
                        echo "Cannot finalize the update to file ${TU_TFILE} while removing tag ${TU_TAG}"
                        echo "Aborting the tag operations"
                        rm -f "${TU_LOCKFILE}"
                        return 22
                    fi 
                    [ "$TU_DEBUG" == "yes" ] && echo "Tag ${TU_TAG} removed successfully from $TU_TFILE"
                fi 
            else
                echo "No tag ${TU_TAG} found in ${TU_TFILE}"
            fi 
        done
        rm -f "${TU_LOCKFILE}"
    else
        [ "$TU_DEBUG" == "yes" ] && echo "Listing tags from $TU_TFILE"
        if [ -f "${TU_TFILE}" ] ; then
            cat "$TU_TFILE"
            if [ $? -ne 0 ] ; then
                echo "Cannot list the tag file ${TU_TFILE}"
                return 30
            fi 
        else
            echo "File not found: ${TU_TFILE}"
        fi 
    fi
    return 0
}

prepareInstallDirs() {
    # Check if we're running in AFS and correct the installation path, if needed
    if [ "`echo $RELLOC | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
        # Check if we are already in the rw path
        if [ "`echo $RELLOC | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
            AFSRELLOC=$RELLOC
            RELLOC="`echo $RELLOC | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
            msgOut INFO "Using physical path $RELLOC"
            msgOut INFO "Will relocate to $AFSRELLOC"
        fi
    fi
    if [ "`echo $SWLOC | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
        # Check if we are already in the rw path
        if [ "`echo $SWLOC | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
            AFSLOC=$SWLOC
            SWLOC="`echo $SWLOC | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
            msgOut INFO "Using logical path $SWLOC"
            msgOut INFO "Will relocate to $AFSLOC"
        fi
    fi

    # Start preparing the dirs
    # Logical install dir
    if [ "$SWPATH" != "" ] ; then
        if [ ! -d $SWPATH ] ; then
            mkdir -p "${SWPATH}"
            NEWLOGPATH=1
        fi
        \find $SWPATH -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
        msgOut INFO "SWPATH: `ls -ld $SWPATH`"
    fi

    # Physical install dir
    if [  ! -d ${RELLOC} ] ; then
        if [ "$AFSRELLOC" != "" ] ; then
            # Create any missing directory
            if [ ! -d "`dirname ${RELLOC}`" ] ; then
                mkdir -p "`dirname ${RELLOC}`"
                NEWPHYSPATH=1
            fi
            # Create a new volume for this physical installation, if possible
            AFSCREATE="`which afs_create 2>/dev/null`"
            if [ "$AFSCREATE" != "" ] ; then
                msgOut INFO "Available disk space in RELLOC before AFS volume creation: `getDiskFree ${RELLOC}`"
                msgOut INFO "Creating a new AFS volume for $RELLOC"
                msgOut INFO "Executing $AFSCREATE ${RELLOC}"
                $AFSCREATE "${RELLOC}"
                [ $? -eq 0 ] && msgOut INFO "AFS volume created successfully" \
                             || msgOut ERROR "Cannot create AFS volume - ErrCode: $?"
                msgOut INFO "Available disk space in RELLOC after AFS volume creation: `getDiskFree ${RELLOC}`"
                msgOut INFO "Mount point info for ${RELLOC}"
                msgOut INFO "`fs lq ${RELLOC}`"
            else
                msgOut WARNING "No afs_create command found"
                msgOut WARNING "PATH=$PATH"
            fi
        fi
    fi
    if [  ! -d ${RELLOC} ] ; then
        mkdir -p "${RELLOC}"
        NEWPHYSPATH=1
    fi
    \find $RELLOC -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
    if [ ! -d ${SWLOC} -a "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "$PRJTYPE" != "eventview" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" -a "$SWLOC" != "$RELLOC" ] ; then
        msgOut ERROR "Missing logical installation dir (${SWLOC}). Trying to create it."
        mkdir -p "${SWLOC}"
        NEWLOGPATH=1
        if [  $? -ne 0  ] ; then
            msgOut ERROR "Cannot create ${SWLOC}."
            return 120
        else
            chmod g-s "${SWLOC}"
            msgOut INFO "Logical installation dir created successfully."
        fi
    fi
    \find $SWLOC -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
    [ -d $SWLOC ] && msgOut INFO "SWLOC: `ls -ld $SWLOC`"
    if [ ! -d ${RELLOC} ] ; then
        msgOut ERROR "Missing physical installation dir (${RELLOC}). Trying to create it."
        mkdir -p "${RELLOC}"
        NEWPHYSPATH=1
        if [  $? -ne 0  ] ; then
            msgOut ERROR "Cannot create ${RELLOC}."
            return 121
        else
            chmod g-s "${RELLOC}"
            msgOut INFO "Physical installation dir created successfully."
        fi
    fi
    \find $RELLOC -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
    [ -d $RELLOC ] && msgOut INFO "RELLOC: `ls -ld $RELLOC`"
    return 0
}


install() {
    cd ${TOPDIR}
    let instrc=0
    SWPHYS=${RELLOC}
    SWLOG=${SWLOC}
    if [ "${SWPATH}" != "" ] ; then
        SWPHYS="$SWPATH"
        SWLOG="$SWPATH"
    fi

    # Release platform,arch and compiler
    REL_PLAT="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\2/g'`"
    REL_ARCH="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\1/g'`"
    REL_COMP="`echo ${ARCH} | sed -e 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\3/g' -e 's/43[5-9]$/43/g' -e 's/46[0-9]$/46/g'`"

    # Check for linked releases
    SKIPPHYSINST=0
    SKIPLOGINST=0
    if [ -n "$PHYSLINK" ] ; then
        if [ -d "$PHYSLINK" -a ! -L "$PHYSLINK" ] ; then
            if [ ! -L "${SWPHYS}" ] ; then
                msgOut INFO "${PHYSLINK} found. Linking ${PHYSLINK} to ${SWPHYS}"
                [ -d ${SWPHYS} -a -n "$NEWPHYSPATH" ] && rm -fr ${SWPHYS}
                ln -sf ${PHYSLINK} ${SWPHYS}
                let instrc=$instrc+$?
                # Convert to relative link only if requested
                [ -L ${SWPHYS} -a -n "$RELLINKS" -a -n "`which symlinks 2>/dev/null`" ] && symlinks -c `dirname ${SWPHYS}`
            fi
            SKIPPHYSINST=1
        else
            if [ ! -L "${PHYSLINK}" ] ; then
                msgOut INFO "Linking ${SWPHYS} to ${PHYSLINK}"
                ln -sf ${SWPHYS} ${PHYSLINK}
                let instrc=$instrc+$?
                # Convert to relative link only if requested
                [ -L ${PHYSLINK} -a -n "$RELLINKS" -a -n "`which symlinks 2>/dev/null`" ] && symlinks -c `dirname ${PHYSLINK}`
            fi
        fi
        msgOut INFO "`ls -ld ${PHYSLINK}`"
    fi
    if [ -n "$LOGLINK" ] ; then
        if [ -d "$LOGLINK" -a ! -L "$LOGLINK" ] ; then
            if [ ! -L "${SWLOG}" ] ; then
                SWLOGRW="`getRWpath ${SWLOG}`"
                msgOut INFO "${LOGLINK} found. Linking ${SWLOGRW} to ${LOGLINK}"
                [ -d ${SWLOGRW} -a -n "$NEWLOGPATH" ] && rm -fr ${SWLOGRW}
                ln -sf ${LOGLINK} ${SWLOGRW}
                let instrc=$instrc+$?
                # Convert the links to relative
                if [ -n "`which symlinks 2>/dev/null`" ] ; then
                    msgOut INFO "Converting links in `dirname ${SWLOGRW}` to relative"
                    symlinks -c `dirname ${SWLOGRW}`
                else
                    msgOut WARNING "No symlinks executable available"
                fi
            fi
            SKIPLOGINST=1
        else
            if [ ! -L "${LOGLINK}" ] ; then
                LOGLINKRW="`getRWpath ${LOGLINK}`"
                msgOut INFO "Linking ${SWLOG} to ${LOGLINKRW}"
                ln -sf ${SWLOG} ${LOGLINKRW}
                let instrc=$instrc+$?
                # Convert the links to relative
                if [ -n "`which symlinks 2>/dev/null`" ] ; then
                    msgOut INFO "Converting links in `dirname ${LOGLINKRW}` to relative"
                    symlinks -c `dirname ${LOGLINKRW}`
                else
                    msgOut WARNING "No symlinks executable available"
                fi
            fi
        fi
        msgOut INFO "`ls -ld ${LOGLINKRW}`"
    fi

    # Check the installation dirs
    prepareInstallDirs
    instrc=$?
    if [ $instrc -ne 0 ] ; then
        msgOut ERROR "Skipping the installation task."
        msgOut INFO "Unlocking the installation area"
        rm -f ${LOCKFILE}
        return $instrc
    fi

    # Define the lock file
    LOCKFILE=${SWPHYS}/atlas-install.lock

    # Wait for previous installation process completion
    if [ -f ${LOCKFILE} ] ; then
        msgOut WARNING "Another installation process is currently active. Now waiting..."
        waittime=0
        while `test -f ${LOCKFILE}`; do
            sleep 1s
            let waittime=$waittime+1
            if [ $waittime -gt 3600 ] ; then
                msgOut WARNING "Timeout [3600 s]"
                msgOut WARNING "Removing stale installation lock"
                rm -f ${LOCKFILE}
            fi
        done
    fi
    set -o noclobber
    msgOut INFO "Locking the installation area"
    lock_retries=0
    max_lock_retries=360
    lock_retry_sleep=10
    while [ $lock_retries -lt $max_lock_retries ] ; do
        echo "$RELEASE installation lock" 2> /dev/null > ${LOCKFILE}
        lsr=$?
        if [ $lsr -ne 0 ] ; then
            msgOut WARNING "Cannot lock the installation area, waiting ${lock_retry_sleep}s"
            let lock_retries=$lock_retries+1
            sleep ${lock_retry_sleep}s
        else
            break
        fi
    done
    set +o noclobber
    if [ $lsr -ne 0 ] ; then
        msgOut ERROR "Cannot lock the installation area after $lock_retries retries"
        return 110
    fi

    case `whoami` in
        usatlas*) msgOut INFO "This is an OSG site with static accounts. No further action required"
            ;;
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
            chmod -R g+rw ${LOCKFILE} 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
        ;;
    esac

    # Installation options
    if [ "$NOCACHE" == "yes" ] ; then
        RELSNAP=${ATLAS}
        GCCSNAP=${LCGCACHE}
        KVSNAP=${LCGCACHE}
    elif [ "${PRJTYPE}" != "poolcond" -a "${PRJTYPE}" != "tdaq" ] ; then
        if [ "$USEPACBALL" != "yes" ] ; then
            SNAPN=${SWPHYS}/atlas-install.snapshot
            snap "${SNAPDIR}" "${SNAPNAME}"
        else
            SNAPN=${SWPHYS}/atlas-install.pacball
            pacball "${SNAPDIR}" "${SNAPNAME}"
        fi
        RELSNAP=${SNAPN}
        GCCSNAP=${SNAPN}
        KVSNAP=${SNAPN}
        let instrc=$instrc+$?
        if [ $instrc -eq 0 ] ; then
            if [ "$USEPACBALL" != "yes" ] ; then
                SNAPSHOT="`\ls -d ${SNAPDIR}/${SNAPNAME}*snap* 2>/dev/null | tail -n 1`"
                if [ "$SNAPSHOT" != "" ] ; then
                    msgOut INFO "Using snapshot ${SNAPSHOT}"
                    msgOut INFO "Linking snapshot to ${SNAPN}"
                    ln -sf ${SNAPSHOT} ${SNAPN}
                    msgOut INFO "`ls -l ${SNAPN}`"
                else
                    msgOut ERROR "Cannot find any snapshot called ${SNAPDIR}/${SNAPNAME}*snap*"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE}
                    return 110
                fi
            else
                PB="`\ls -d ${SNAPDIR}/${SNAPNAME} 2>/dev/null | tail -n 1`"
                if [ "$PB" != "" ] ; then
                    msgOut INFO "Using pacball ${PB}"
                    msgOut INFO "Linking pacball to ${SNAPN}"
                    ln -sf ${PB} ${SNAPN}
                    msgOut INFO "`ls -l ${SNAPN}`"
                else
                    msgOut ERROR "Cannot find any pacball called ${SNAPDIR}/${SNAPNAME}"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE}
                    return 110
                fi
            fi
        else
            msgOut INFO "Unlocking the installation area"
            rm -f ${LOCKFILE}
            return $instrc
        fi
    fi

    # Main release path
    [ -n "${MAINRELPATH}" ] && RELPATH="${MAINRELPATH}" || RELPATH="${RELLOC}"

    # Main release version
    MAINRELVER="`echo $RELEASE | awk -F "." '{for (i=1;i<=3;i++) ver=sprintf("%s%02d",ver,$i)}END{print int(ver)}'`"

    # Handle the patches to releases and EventView caches
    if [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" -o "$PRJTYPE" == "t0patch" -o "${PRJTYPE}" == "p1nightly" -o "${PRJTYPE}" == "eventview" -o "$PRJTYPE" == "analysis" ] ; then
        if [ "$PRJTYPE" == "analysis" -a "${REQPRJNAME}" != "AtlasOffline" ] ; then
            MAINRELEASE="`echo $RELEASE | cut -d "." -f 1-4`"
        else
            MAINRELEASE="`echo $RELEASE | cut -d "." -f 1-3`"
        fi
        RELMAJOR="`echo $RELEASE | cut -d "." -f 1`"
        if [ $RELMAJOR -lt 12 ] ; then
            msgOut ERROR "Installation of patches or PAT tools not supported for releases < 12.0.0"
            msgOut INFO "Unlocking the installation area"
            rm -f ${LOCKFILE}
            return 130
        fi
        if [ ! -s ${RELPATH}/cmtsite/setup.sh -a ! -s ${RELPATH}/cmtsite/asetup.sh ] ; then
            msgOut ERROR "No $MAINRELEASE release setup file found in ${RELPATH}. Please install $MAINRELEASE first."
            msgOut INFO "Unlocking the installation area"
            rm -f ${SNAPN}
            rm -f ${LOCKFILE}
            return 131
        fi

        # Setup the main release
        [ "${REQPRJNAME}" != "" ] && RPNAME="${REQPRJNAME}" || RPNAME="${PRJNAME}"
        [ "$RPNAME" == "tdaq" ] && RPNAME="AtlasOffline"
        msgOut INFO "Trying to setup $RPNAME $MAINRELEASE."

        # Set some additional tags
        RUNTIME_TAGS=",gcc${REL_COMP},slc${REL_PLAT}"
        [ "$REL_ARCH" == "i686" ] && RUNTIME_TAGS="${RUNTIME_TAGS},32" || RUNTIME_TAGS="${RUNTIME_TAGS},64"
        ARUNTIME_TAGS="gcc${REL_COMP} slc${REL_PLAT}"
        [ "$REL_ARCH" == "i686" ] && ARUNTIME_TAGS="${ARUNTIME_TAGS} 32" || ARUNTIME_TAGS="${ARUNTIME_TAGS} 64"

        # Setup the release
        unset CMTPATH
        if [ -s "${RELPATH}/cmtsite/asetup.sh" -a $MAINRELVER -ge 160000 ] ; then
            # Save the PATH, LD_LIBRARY_PATH and PYTHONPATH
            OLD_PATH=$PATH
            OLD_LD_LIBRARY_PATH=$LD_LIBRARY_PATH
            OLD_PYTHONPATH=$PYTHONPATH
            # Use AtlasSetup
            msgOut INFO "AtlasSetup: source ${RELPATH}/cmtsite/asetup.sh ${MAINRELEASE} ${RPNAME} ${PRJOPT} ${ARUNTIME_TAGS}"
            source ${RELPATH}/cmtsite/asetup.sh ${MAINRELEASE} ${RPNAME} ${PRJOPT} ${ARUNTIME_TAGS}
            # Always restore the old PATH, LD_LIBRARY_PATH and PYTHONPATH. Use the system python
            export PATH=$OLD_PATH
            export LD_LIBRARY_PATH=$OLD_LD_LIBRARY_PATH
            export PYTHONPATH=$OLD_PYTHONPATH
            export PATH=/usr/bin:$PATH
        else
            ALREQ="`\ls -d ${RELPATH}/AtlasLogin/*/cmt/requirements 2> /dev/null | sort | tail -n 1`"
            if [ "$ALREQ" != "" ] ; then
                # Get the early AtlasLogin patches, if any
                wget --spider --quiet ${ATLASLOGINPATCHURL}/${RELEASE}/requirements
                if [ $? -eq 0 ] ; then
                    msgOut INFO "Overwriting $ALREQ with ${ATLASLOGINPATCHURL}/${RELEASE}/requirements"
                    curl -S ${ATLASLOGINPATCHURL}/${RELEASE}/requirements > $ALREQ
                    [ -f "${ALREQ}.orig" ] && rm -f ${ALREQ}.orig
                else
                    msgOut INFO "No AtlasLogin patches found on ${ATLASLOGINPATCHURL} for release ${RELEASE}"
                fi
                ALREQPATCHED="yes"
            fi

            # Use AtlasLogin
            msgOut INFO "AtlasLogin: source ${RELPATH}/cmtsite/setup.sh -tag=${MAINRELEASE},${RPNAME},${PRJOPT}${RUNTIME_TAGS}"
            source ${RELPATH}/cmtsite/setup.sh -tag=${MAINRELEASE},${RPNAME},${PRJOPT}${RUNTIME_TAGS}
            # Always use the system python
            export PATH=/usr/bin:$PATH
        fi
        msgOut INFO "CMTPATH=$CMTPATH"
        msgOut INFO "ATHENA: `which athena 2>/dev/null`"
        if [ -z "${CMTPATH}" ] ; then
            msgOut ERROR "${RPNAME} $MAINRELEASE not found in $RELPATH. Please install ${RPNAME} $MAINRELEASE first."
            msgOut INFO "Unlocking the installation area"
            rm -f ${SNAPN}
            rm -f ${LOCKFILE}
            return 132
        else
            msgOut INFO "${RPNAME} ${MAINRELEASE} found in $SITEROOT."
        fi
    fi

    # Setup the DDM
    if [ -n "$DDMSETUP" -a -n "$OSG_APP" -a -s "$OSG_APP/atlas_app/atlaswn/setup.sh" ] ; then
        DDMSETUP="$OSG_APP/atlas_app/atlaswn/setup.sh"
        msgOut INFO "Overriding the DDM location with $DDMSETUP"
    fi
    if [ "$DDMSETUP" != "" -a -s "$DDMSETUP" ] ; then
        source $DDMSETUP
        if [ $? -eq 0 ] ; then
            msgOut INFO "DDM configured from $DDMSETUP"
        else
            msgOut ERROR "Cannot configure DDM from $DDMSETUP"
        fi
    else
        [ "$DDMSETUP" != "" ] && msgOut ERROR "No DDM setup file found in $DDMSETUP"
    fi

    # Start the installation
    cd "${SWPHYS}"
    msgOut INFO "Starting the installation"
    msgOut INFO "Installation type: ${PRJNAME}"
    msgOut INFO "PATH=${PATH}"
    msgOut INFO "Physical area: ${SWPHYS}"
    [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "${PRJTYPE}" != "eventview" -a "${PRJTYPE}" != "analysis" -a "$SWLOC" != "$RELLOC" -a "$PRJTYPE" != "tdaq" ] && \
    msgOut INFO "Logical area:  ${SWLOG}"
    msgOut INFO "Starting physical installation in ${PWD}"
    if [ "$DEBUG" == "yes" ] ; then
        msgOut DEBUG "PATH=${PATH}"
        msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
        msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
    fi
    msgOut INFO "Listing the current directory contents"
    msgOut INFO "`\ls -l`"

    if [ $SKIPPHYSINST -eq 0 ] ; then
        if [ "${PRJTYPE}" == "poolcond" ] ; then
            (genPoolcondPFC)
            let instrc=$?
            if [ $instrc -eq 0 -a -z "$SKIPLOCALCONF" -a "$GRIDNAME" != "NORDUGRID" ] ; then
                msgOut INFO "Creating or updating the local configuration setup"
                setLocalConfig
                let instrc=$instrc+$?
            else
                msgOut INFO "Skipping the local configuration setup"
            fi
        elif [ "${PRJTYPE}" == "tdaq" ] ; then
            [ ! -d ".rpmdb" ] && mkdir .rpmdb
            msgOut INFO "Starting the installation of ${ATLASRELEASE} via rpm"
            msgOut INFO "Downloading packages"
            #RPMPKGARCH="`echo $ARCH | sed -e 's/^_//' -e 's/_/-/g'`-${PRJOPT}"
            RPMPKGARCH="`echo $ARCH | sed 's/^_*\(.*\)_slc\([0-9]*\)_gcc\([0-9]*\)/\1-slc\2-gcc\3/g'`-${PRJOPT}"
            msgOut INFO "wget -r -nd -Nd -l3 -erobots=off -P RPMCACHE -A ${ATLASRELEASE}*_${RPMPKGARCH}*rpm -A ${ATLASRELEASE}*_noarch*rpm ${ATLAS}"
            wget -r -nd -Nd -l3 -erobots=off -P RPMCACHE -A "${ATLASRELEASE}*_${RPMPKGARCH}*rpm" -A "${ATLASRELEASE}*_noarch*rpm" ${ATLAS}
            let instrc=$instrc+$?
            if [ $instrc -eq 0 ] ; then
                msgOut INFO "Installing packages"
                rpm --nodeps --noscripts -Uhv --prefix=$PWD --dbpath $PWD/.rpmdb RPMCACHE/${ATLASRELEASE}*
                let instrc=$instrc+$?
                if [ $instrc -eq 0 ] ; then
                    msgOut INFO "RPM packages installed successfully"
                    rm -fr RPMCACHE
                else
                    msgOut ERROR "Cannot install rpm packages"
                fi
            else
                msgOut ERROR "Cannot download tdaq packages"
            fi
        else
            if [ "$PACMAN_OPTS" != "" -a "$USEPACBALL" != "yes" ] ; then
                msgOut INFO "pacman $PACMAN_OPTS"
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                pacman $PACMAN_OPTS
                let instrc=$instrc+$?
                if [ `echo $PACMAN_VER | awk -F. '{printf "%d%02d%02d",$1,$2,$3}'` -lt 31800 ] ; then
                    pacman -v down tar up
                else
                    msgOut INFO "pacman -v download tar up $PACMAN_OPTS"
                    pacman -v download tar up $PACMAN_OPTS
                fi
                let instrc=$instrc+$?
                pacman -def
                let instrc=$instrc+$?
            fi
            rm -f *.tar

            if [ "$PACKOPT" == "all" -a "$USEPACBALL" != "yes" ] ; then
                # Install the compiler for this release using the cached files
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                PACMAN_CMD="-get ${GCCSNAP}:${RELEASE}/${GCC}"
                [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${GCCSNAP}:${RELEASE}/${GCC}"
                msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                echo y | \
                pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                let instrc=$instrc+$?
                source setup.sh
            elif [ "$PACKOPT" != "all" -a "$INSTCOMPILER" != "" ] ; then
                COMPILER_VER="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\3/g'`"
                [ ! -d $VO_ATLAS_SW_DIR/gcc/${COMPILER_VER} ] && mkdir -p $VO_ATLAS_SW_DIR/gcc/${COMPILER_VER}
                cd $VO_ATLAS_SW_DIR/gcc/${COMPILER_VER}
                msgOut INFO "Installing the compiler ${GCC} in ${PWD}"
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                PACMAN_CMD="-get ${LCGCACHE}:${RELEASE}/${GCC}"
                [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${LCGCACHE}:${RELEASE}/${GCC}"
                msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                echo y | pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                let instrc=$instrc+$?
                source setup.sh
                cd -

                # Add this custom compiler to the list of site compilers
                if [ $instrc -eq 0 -a "${GCC_DIR}" != "" ] ; then
                    setCompiler $VO_ATLAS_SW_DIR/gcc/${COMPILER_VER}/${GCC_DIR}
                else
                    msgOut INFO "Compiler installation failed or GCC_DIR not set"
                fi
            fi
            # Install the selected extra packages
            if [ "$EXTRAPKG" != "" ] ; then
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                PACMAN_CMD="-get ${RELSNAP}:${EXTRAPKG}"
                [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${RELSNAP}:${EXTRAPKG}"
                msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                echo y | \
                pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                prc=$?
                [ $prc -ne 0 ] && msgOut ERROR "pacman return code: $prc"
                let instrc=$instrc+$prc
                if [ $instrc -ne 0 ] ; then
                    msgOut ERROR "Physical area installation FAILED"
                    msgOut ERROR "`pacman -last 2>&1`"
                    pacman -lc | sed 's/^ *//g' | grep '^\[X\]' | awk '{print $NF}' | while read OFFENDINGPKG; do
                        msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                        pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                        if [ $? -eq 0 ] ; then
                            msgOut INFO "Offending package $OFFENDINGPKG removed successfully."
                        else
                            msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                            msgOut ERROR "`pacman -last 2>&1`"
                        fi
                    done
                    OFFPKGS="`pacman -lc | sed 's/^ *//g' | grep '^\[X\]' | awk '{print $NF}' | wc -l`"
                    if [ $OFFPKGS -eq 0 ] ; then
                        msgOut INFO "All broken packages removed successfully. Now retrying with pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                        echo y | \
                        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                        let instrc=$?
                    else
                        msgOut ERROR "$OFFPKGS broken packages detected"
                    fi
                    if [ $instrc -ne 0 ] ; then
                        msgOut ERROR "Physical area installation FAILED"
                        msgOut ERROR "`pacman -last 2>&1`"
                        msgOut INFO "Unlocking the installation area"
                        rm -f ${LOCKFILE}
                        return $instrc
                    fi
                fi
            fi

            # Handle the site compilers
            msgOut INFO "Searching for site compilers"
            for SYSTEM_ARCH in i686 x86_64; do
                COMPILER_ARCH="`echo ${ARCH} | sed -e "s/i686/$SYSTEM_ARCH/g" -e "s/x86_64/$SYSTEM_ARCH/g"`"
                COMPILER_VER="`echo ${COMPILER_ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\3/g'`"
                # Use gcc 4.3.5 by default for releases >= 17.0.1, even if not specified
                if [ "$COMPILER_VER" == "43" -a $MAINRELVER -ge 170001 ] ; then
                    COMPILER_ARCH="`echo $COMPILER_ARCH | sed 's/gcc43/gcc435/g'`"
                    COMPILER_VER="435" 
                fi
                msgOut INFO "Target site compiler is $COMPILER_VER (${COMPILER_ARCH} setup)"
                if [ "$COMPILER_HOME" == "" ] ; then
                    # Search for the gcc setup file and get the info from there
                    # Revert to a basic search in $VO_ATLAS_SW_DIR in case the gcc setup
                    # is not available
                    if [ -s "$SITECONF" ] ; then
                        msgOut INFO "Getting the site compiler path from $SITECONF"
                        COMPILER_PATH="`cat $SITECONF | grep -v ^# | grep gcc${COMPILER_ARCH}= | tail -n 1 | cut -d= -f 2`"
                        if [ "$COMPILER_PATH" == "" ] ; then
                            COMPILER_PATH="`cat $SITECONF | grep -v ^# | grep ^gcc${COMPILER_VER}= | tail -n 1 | cut -d= -f 2`"
                        fi
                        if [ "$COMPILER_PATH" == "" ] ; then
                            msgOut WARNING "No path matching gcc${COMPILER_ARCH} or gcc${COMPILER_VER} in $SITECONF"
                            msgOut WARNING "Listing the contents of $SITECONF"
                            msgOut WARNING "`cat $SITECONF`"
                        else
                            eval COMPILER_HOME_${SYSTEM_ARCH}=\"`/bin/ls -d $COMPILER_PATH 2>/dev/null | tail -n 1`\"
                        fi
                    else
                        COMPILER_PATH="$VO_ATLAS_SW_DIR"
                        if [ "$VO_ATLAS_SW_DIR" == "" ] ; then
                            if [ "${SWLOG}" != "" -a "${SWPHYS}" != "" ] ; then
                                COMPILER_PATH="`echo ${SWLOG} ${SWPHYS} | awk '{split($1,a,"/"); split ($2,b,"/"); for (i=2;i<length(a);i++) {if (a[i]==b[i]) printf "/%s", a[i];}}'`"
                            else
                                COMPILER_PATH="${TOPDIR}"
                            fi
                            eval COMPILER_HOME_${SYSTEM_ARCH}=\"`/bin/ls -d $COMPILER_PATH/gcc/${COMPILER_VER}* 2>/dev/null | tail -n 1`\"
                        fi
                    fi
                    if [ "$COMPILER_PATH" != "" ] ; then
                        msgOut INFO "Looking for a site compiler in $COMPILER_PATH"
                    fi
                fi
            done
            # Create the AtlasSite (if not yet there) in case a custom compiler is found,
            # the ATLAS_CONDDB reference gatekeep must be set or a Frontier setup is needed
            [ -s ${RELPATH}/AtlasSite/cmt/requirements -a "${PRJTYPE}" == "release" -a "${PRJNAME}" != "gcc" ] && rm -f ${RELPATH}/AtlasSite/cmt/requirements
            if [ ! -s ${RELPATH}/AtlasSite/cmt/requirements -a "$PRJTYPE" != "ext" ] ; then
                if [ -n "$COMPILER_HOME_i686" -o -n "$COMPILER_HOME_x86_64" ] ; then
                    if [ ! -d ${RELPATH}/AtlasSite/cmt ] ; then
                        mkdir -p ${RELPATH}/AtlasSite/cmt
                        \find $RELPATH/AtlasSite -type d ! -perm -a+rx -exec chmod -R a+rx {} \;
                    fi
cat > ${RELPATH}/AtlasSite/cmt/requirements <<EOAS
macro setup_site_gcc "\$(ATLASSITEROOT)/cmt/setup_site_gcc"
setup_script \$(setup_site_gcc)
EOAS
cat > ${RELPATH}/AtlasSite/cmt/setup_site_gcc.sh <<EOCS
#!/bin/sh
[ -z "\$COMPILER_ARCH_OVERRIDE" ] && COMPILER_ARCH_OVERRIDE="\`uname -m\`"
EOCS
cat > ${RELPATH}/AtlasSite/cmt/setup_site_gcc.csh <<EOCS
#!/bin/csh
if ( ! \$?COMPILER_ARCH_OVERRIDE ) then
    set COMPILER_ARCH_OVERRIDE="\`uname -m\`"
endif
EOCS
                fi
                unset COMPILER_FOUND
                for SYSTEM_ARCH in i686 x86_64; do
                    eval CURRENT_CH="\$COMPILER_HOME_${SYSTEM_ARCH}"
                    if [ -n "$CURRENT_CH" ] ; then
                        msgOut INFO "Site compiler for $SYSTEM_ARCH found in $CURRENT_CH"
                        COMPILER_BIN="`find -L $CURRENT_CH -xtype d -name bin 2>/dev/null | tail -n 1`"
                        COMPILER_LIB="`find -L $CURRENT_CH -xtype d -name lib 2>/dev/null | tail -n 1`"
                        COMPILER_LIB64="`find -L $CURRENT_CH -xtype d -name lib64 2>/dev/null | tail -n 1`"
                        [ "$COMPILER_LIB64" != "" ] && COMPILER_LIB="${COMPILER_LIB}:${COMPILER_LIB64}"
                        if [ "$COMPILER_BIN" != "" -a "$COMPILER_LIB" != "" ] ; then
                            COMPILER_FOUND=y
                            msgOut INFO "$SYSTEM_ARCH site compiler bin found in $COMPILER_BIN"
                            msgOut INFO "$SYSTEM_ARCH site compiler lib found in $COMPILER_LIB"
                            [ ! -d "${RELPATH}/AtlasSite/gcc-links" ] && mkdir -p ${RELPATH}/AtlasSite/gcc-links
                            COMPILER_LINK="${SYSTEM_ARCH}`echo ${ARCH} | sed -e 's/^_*i686//' -e 's/^_*x86_64//' -e 's/_/-/g' -e 's/gcc43[5-9]/gcc43/g' -e 's/gcc46[0-9]/gcc46/g'`-opt"
                            msgOut INFO "Linking `dirname ${COMPILER_BIN}` to ${RELPATH}/AtlasSite/gcc-links/${COMPILER_LINK}"
                            [ -L ${RELPATH}/AtlasSite/gcc-links/${COMPILER_LINK} ] && rm -f ${RELPATH}/AtlasSite/gcc-links/${COMPILER_LINK}
                            ln -sf `dirname ${COMPILER_BIN}` ${RELPATH}/AtlasSite/gcc-links/${COMPILER_LINK}
                            [ -L ${RELPATH}/AtlasSite/gcc-links/${COMPILER_LINK} -a -n "$RELLINKS" -a -n "`which symlinks 2>/dev/null`" ] && symlinks -c ${RELPATH}/AtlasSite/gcc-links
cat >> ${RELPATH}/AtlasSite/cmt/setup_site_gcc.sh <<EOCS
if [ "\$COMPILER_ARCH_OVERRIDE" = "$SYSTEM_ARCH" ] ; then
    export PATH=$COMPILER_BIN:\$PATH
    export LD_LIBRARY_PATH=$COMPILER_LIB:\$LD_LIBRARY_PATH
fi
EOCS
cat >> ${RELPATH}/AtlasSite/cmt/setup_site_gcc.csh <<EOCS
if ( "\$COMPILER_ARCH_OVERRIDE" == "$SYSTEM_ARCH" ) then
    setenv PATH $COMPILER_BIN:\$PATH
    setenv LD_LIBRARY_PATH $COMPILER_LIB:\$LD_LIBRARY_PATH
endif
EOCS
                        elif [ -z "$COMPILER_FOUND" ] ; then
                            msgOut WARNING "No bin or lib found in the $SYSTEM_ARCH site compiler. Will use the site compiler"
                            SITECOMPVER="`gcc -v 2>&1 | grep "^gcc version" | awk '{print $3}' | sed 's/\.//g'`"
                            if [ "`echo $SITECOMPVER | grep ^$COMPILER_VER 2>/dev/null`" == "" ] ; then
                                if [ "$REQCOMPILER" == "yes" ] ; then
                                    msgOut ERROR "The $SYSTEM_ARCH site compiler is version $SITECOMPVER while you requested version $COMPILER_VER"
                                    msgOut INFO "Unlocking the installation area"
                                    [ -f ${LOCKFILE} ] && rm -f ${LOCKFILE}
                                    cd ${TOPDIR}
                                    return $instrc
                                else
                                    msgOut WARNING "The $SYSTEM_ARCH site compiler is version $SITECOMPVER while you need version $COMPILER_VER"
                                fi
                            fi
                            msgOut INFO "Listing the directory structure of $COMPILER_HOME"
                            msgOut INFO "`find -L $COMPILER_HOME -xtype d -exec /bin/ls -ld {} \;`"
                        fi
                    elif [ -z "$COMPILER_FOUND" ] ; then
                        msgOut INFO "No $SYSTEM_ARCH site compiler found, will use the system compiler"
                        SITECOMPVER="`gcc -v 2>&1 | grep "^gcc version" | awk '{print $3}' | sed 's/\.//g'`"
                        if [ "`echo $SITECOMPVER | grep ^$COMPILER_VER 2>/dev/null`" == "" ] ; then
                            if [ "$REQCOMPILER" == "yes" ] ; then
                                msgOut ERROR "The $SYSTEM_ARCH site compiler is version $SITECOMPVER while you requested version $COMPILER_VER"
                                msgOut INFO "Unlocking the installation area"
                                [ -f ${LOCKFILE} ] && rm -f ${LOCKFILE}
                                cd ${TOPDIR}
                                return $instrc
                            else
                                msgOut WARNING "The $SYSTEM_ARCH site compiler is version $SITECOMPVER while you need version $COMPILER_VER"
                            fi
                        fi
                    fi
                done
                # Add the CONDDB host
                if [ "$TAGHOST" != "" ] ; then
                    if [ ! -d ${RELPATH}/AtlasSite/cmt ] ; then
                        mkdir -p ${RELPATH}/AtlasSite/cmt
                        \find $RELPATH/AtlasSite -type d ! -perm -a+rx -exec chmod -R a+rx {} \;
                    fi
                    msgOut INFO "Setting ATLAS_CONDDB to $TAGHOST in AtlasSite"
cat >> ${RELPATH}/AtlasSite/cmt/requirements <<EOAS
set ATLAS_CONDDB $TAGHOST
EOAS
                fi
                # Frontier setup
                if [ "$ATLAS_FRONTIER_CONF" != "" -a  "$SETFRONTIER" == "y" ] ; then
                    if [ ! -d ${RELPATH}/AtlasSite/cmt ] ; then
                        mkdir -p ${RELPATH}/AtlasSite/cmt
                        \find $RELPATH/AtlasSite -type d ! -perm -a+rx -exec chmod -R a+rx {} \;
                    fi
                    msgOut INFO "Setting FRONTIER_SERVER to \$ATLAS_FRONTIER_CONF in AtlasSite"
cat >> ${RELPATH}/AtlasSite/cmt/requirements <<EOAS
set FRONTIER_SERVER \$(ATLAS_FRONTIER_CONF)
EOAS
                fi
            else
                [ "$PRJTYPE" != "ext" ] && msgOut WARNING "A site requirements is already present in ${RELPATH}/AtlasSite/cmt/requirements. I will not overwrite it"
            fi

            # Install the selected release
            if [ "$USEPACBALL" != "yes" ] ; then
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                PACMAN_CMD="-get \"${RELSNAP}:${ATLASRELEASE}\""
                [ "$UPDATE" == "yes" ] && PACMAN_CMD="$PACMAN_CMD -update ${RELSNAP}:${ATLASRELEASE}"
                msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                echo y | \
                  eval pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                prc=$?
                [ $prc -ne 0 ] && msgOut ERROR "pacman return code: $prc"
                let instrc=$instrc+$prc
            else
                ATLASRELEASEFNAME="`\ls -d ${RELSNAP} 2>/dev/null`"
                if [ "$ATLASRELEASEFNAME" != "" ] ; then
                    msgOut INFO "Executing /bin/bash ${ATLASRELEASEFNAME} ${ATLASRELEASE}"
                    /bin/bash ${ATLASRELEASEFNAME} ${ATLASRELEASE}
                    pbinstrc=$?
                    if [ $pbinstrc -ne 0 ] ; then
                        [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                        msgOut WARNING "Clearing pacman locks and retrying"
                        pacman -clear-lock
                        if [ $? -eq 0 ] ; then
                            msgOut INFO "Locks cleared, retrying the installation"
                            /bin/bash ${ATLASRELEASEFNAME} ${ATLASRELEASE}
                            pbinstrc=$?
                        else
                            msgOut ERROR "Cannot clear locks"
                        fi
                    fi
                    let instrc=$instrc+$pbinstrc
                else
                    msgOut ERROR "Cannot find ${RELSNAP}"
                    let instrc=$instrc+15
                fi
            fi
            if [ $instrc -ne 0 ] ; then
                msgOut ERROR "Physical area installation FAILED"
                [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                msgOut ERROR "`pacman -last 2>&1`"

                # Try to fix the broken installations
                pacman -lc | sed 's/^ *//g' | grep '^\[X\]' | awk '{print $NF}' | while read OFFENDINGPKG; do
                    msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                    pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                    if [ $? -eq 0 ] ; then
                        msgOut INFO "Offending package $OFFENDINGPKG removed successfully."
                    else
                        msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                        msgOut ERROR "`pacman -last 2>&1`"
                    fi
                done
                OFFPKGS="`pacman -lc | sed 's/^ *//g' | grep '^\[X\]' | awk '{print $NF}' | wc -l`"
                if [ $OFFPKGS -eq 0 ] ; then
                    msgOut INFO "All broken packages removed successfully. Now retrying with pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                    echo y | \
                    eval pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                    let instrc=$?
                else
                    msgOut ERROR "$OFFPKGS broken packages detected"
                fi
                if [ $instrc -ne 0 ] ; then
                    msgOut ERROR "Physical area installation FAILED"
                    msgOut ERROR "`pacman -last 2>&1`"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE} ${SNAPN}
                    return $instrc
                fi
            fi

            # DQ2 clients patches
            rm -fr post-setup
            if [ "${PRJTYPE}" == "ext" -a "${PRJNAME}" == "DQ2Clients" ] ; then
                wget --spider --quiet ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                if [ $? -eq 0 ] ; then
                    mkdir post-setup
                    cd post-setup
                    msgOut INFO "Installing DQ2 helper scripts for release ${RELEASE}"
                    wget -r --no-parent -A "*.sh" --quiet -nd ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                    wget -r --no-parent -A "*.csh" --quiet -nd ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                    cd ..
                else
                    msgOut INFO "No DQ2 helper scripts found for release ${RELEASE}"
                fi
            fi

            # Clean snapshots
            [ "$USEPACBALL" != "yes" ] && pacman -clear-snapshots

            if [ "$ALREQPATCHED" != "yes" ] ; then
                # Get the AtlasLogin patches, if any
                wget --spider --quiet ${ATLASLOGINPATCHURL}/${RELEASE}/requirements
                if [ $? -eq 0 ] ; then
                    ALREQ="`\ls -d AtlasLogin/*/cmt/requirements | sort | tail -n 1`"
                    msgOut INFO "Overwriting $ALREQ with ${ATLASLOGINPATCHURL}/${RELEASE}/requirements"
                    curl -s -S ${ATLASLOGINPATCHURL}/${RELEASE}/requirements > $ALREQ
                    [ -f "${ALREQ}.orig" ] && rm -f ${ALREQ}.orig
                else
                    msgOut INFO "No AtlasLogin patches found on ${ATLASLOGINPATCHURL} for release ${RELEASE}"
                fi
            fi

            if [ -d "AtlasSetup" ] ; then
                # Get the AtlasSetup patches, if any
                wget --spider --quiet ${ATLASSETUPPATCHURL}/${RELEASE}/AtlasSetup-${RELEASE}.patch
                if [ $? -eq 0 ] ; then
                    curl -s -S ${ATLASSETUPPATCHURL}/${RELEASE}/version.cmt > AtlasSetupVersion
                    diff -q AtlasSetupVersion AtlasSetup/cmt/version.cmt &> /dev/null
                    if [ $? -ne 0 ] ; then
                        wget -N -c --quiet ${ATLASSETUPPATCHURL}/${RELEASE}/AtlasSetup-${RELEASE}.patch
                        if [ -s "AtlasSetup-${RELEASE}.patch" ] ; then
                            msgOut INFO "Patching `cat AtlasSetup/cmt/version.cmt` with AtlasSetup-${RELEASE}.patch"
                            patch -p0 -N -s < AtlasSetup-${RELEASE}.patch
                        fi
                    else
                        msgOut INFO "Will not patch AtlasSetup since you already have `cat AtlasSetup/cmt/version.cmt`"
                    fi
                    rm -f AtlasSetup-${RELEASE}.patch AtlasSetupVersion
                else
                    msgOut INFO "No AtlasSetup patches found on ${ATLASSETUPPATCHURL} for release ${RELEASE}"
                fi
            fi

            # DB release
            if [ "$DBREL" != "" ] ; then
                # Check and fix the "DBRelease" directory if we are not the owners
                DBRELFIX="DBRelease"
                if [ -d DBRelease -a "`ls -ld $DBRELFIX 2>/dev/null | awk '{print $3}'`" != "`whoami`" ] ; then
                    msgOut INFO "Fixing the $DBRELFIX directory to be able to write there"
                    cp -a ${DBRELFIX} ${DBRELFIX}.new
                    if [ $? -eq 0 ] ; then
                        cd ${DBRELFIX}
                        find . -type f -exec md5sum {} \; > ../MD5SUM
                        cd ../${DBRELFIX}.new
                        md5sum -c ../MD5SUM > /dev/null
                        dbrf_rc=$?
                        cd ..
                        rm -f MD5SUM
                        if [ $dbrf_rc -eq 0 ] ; then
                            mv ${DBRELFIX} ${DBRELFIX}.old
                            mv ${DBRELFIX}.new ${DBRELFIX}
                            rm -fr ${DBRELFIX}.old
                            msgOut INFO "$DBRELFIX successfully fixed"
                        else
                            msgOut ERROR "Fixed $DBRELFIX differs from the original. Keeping the original copy."
                            rm -fr ${DBRELFIX}.new
                        fi
                    else
                        msgOut ERROR "Cannot fix $DBRELFIX"
                    fi
                fi
                # Perform the DBRelease installation
                if [ "`which pacman 2>/dev/null`" == "" ] ; then
                    setupPacman
                else
                    PV="`pacman -V | grep -i "^pacman version" | cut -d: -f 2 | awk '{print $1}'`"
                    if [ "$PV" != "$PACMAN_VER" ] ; then
                        msgOut INFO "Your pacman is v$PV but we need v$PACMAN_VER will try to setup it"
                        setupPacman
                    fi
                fi
                LATEST_DBREL_INFO="`ls DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1`"
                LATEST_DBREL_SEQ="`echo $LATEST_DBREL_INFO | awk '{print $1}'`"
                LATEST_DBREL_VER="`echo $LATEST_DBREL_INFO | awk '{print $2}'`"
                DBREL_SEQ="`echo $DBREL | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i;}'`"
                if [ $DBREL_SEQ -gt $LATEST_DBREL_SEQ ] ; then
                    PACMAN_CMD="-get ${DBRELCACHE}:${DBRELPKG}"
                    msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                    echo y | \
                    pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                    let instrc=$instrc+$?
                    if [ $instrc -ne 0 ] ; then
                        msgOut ERROR "DB release installation FAILED"
                        msgOut ERROR "`pacman -last 2>&1`"
                        OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
                        # Try to fix the broken installations, in case we're not using pacballs
                        if [ "$OFFENDINGPKG" != "" -a "$USEPACBALL" != "yes" ] ; then
                            msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                            pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                            if [ $? -eq 0 ] ; then
                                msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                                pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                                let instrc=$?
                            else
                                msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                                msgOut ERROR "`pacman -last 2>&1`"
                            fi
                        fi
                        if [ $instrc -ne 0 ] ; then
                            msgOut ERROR "Physical area installation FAILED"
                            msgOut ERROR "`pacman -last 2>&1`"
                        fi
                    fi
                else
                    msgOut INFO "Will not install DBRelease $DBREL since you already have DBRelease $LATEST_DBREL_VER"
                fi
                # Cleanup the obsolete DB Releases
                if [ "$DBRELCLEAN" == "yes" ] ; then
                    # Check again for the latest DBRelease as we could have installed one in the meantime
                    OLDER_DBREL_INFO="`ls DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | head -n 1`"
                    LATEST_DBREL_INFO="`ls DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1`"
                    OLDER_DBREL_VER="`echo $OLDER_DBREL_INFO | awk '{print $2}'`"
                    LATEST_DBREL_VER="`echo $LATEST_DBREL_INFO | awk '{print $2}'`"
                    /bin/ls DBRelease | egrep -v "^current$|^${OLDER_DBREL_VER}$|^${LATEST_DBREL_VER}$" | \
                    while read dbr; do
                        msgOut INFO "Removing DBRelease-$dbr"
                        pacman -remove DBRelease-$dbr
                        dbrrc=$?
                        let instrc=$instrc+$dbrrc
                        [ $dbrrc -ne 0 ] && msgOut ERROR "Cannot remove DBRelease-$dbr. `pacman -last 2>&1`"
                    done
                    if [ -d "DBRelease" ] ; then
                        # Fix broken current links
                        if [ ! -d "DBRelease/current" ] ; then
                            msgOut INFO "Linking DBRelease $LATEST_DBREL_VER as current"
                            (
                                cd DBRelease
                                if [ $? -eq 0 ] ; then
                                    rm -f current
                                    ln -s $LATEST_DBREL_VER current
                                    cd ..
                                fi
                            )
                        fi
                        msgOut INFO "Current DBRelease: `ls -l DBRelease/current 2>/dev/null`"
                    else
                        msgOut ERROR "No DBRelease found!"
                        let instrc=$instrc+50
                    fi
                fi
            fi
        fi
    else
        msgOut INFO "Skipping the Physical installation"
    fi

    if [ $SKIPLOGINST -eq 0 ] ; then
        # Create the logical installation for the selected release
        if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "${PRJTYPE}" != "eventview" -a "${PRJTYPE}" != "analysis" -a "$PRJTYPE" != "tdaq" -a "${SWLOC}" != "${RELLOC}" ] ; then
            [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
            cd "${SWLOG}"
            msgOut INFO "Starting the logical installation in ${PWD}"
            SWLOCBD="`date +%s`"
            rm -fr *
            if [ "$PACKOPT" == "all" -a "$USEPACBALL" != "yes" ] ; then
                echo y | \
                pacman ${PACMAN_OPTS} \
                       -get ${RELLOC}:${RELEASE}/${GCC}
                let instrc=$instrc+$?
                echo y | \
                pacman ${PACMAN_OPTS} \
                       -get ${KVSNAP}:${RELEASE}/${KV}
                let instrc=$instrc+$?
            fi
            PACMAN_CMD="-get ${RELLOC}:${ATLASRELEASE}"
            msgOut INFO "Executing pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
            echo y | pacman ${PACMAN_OPTS} ${PACMAN_CMD}
            insttmprc=$?
            if [ $insttmprc -ne 0 ] ; then
                PACMAN_CMD_NEW="`echo ${PACMAN_CMD} | sed 's/AtlasOffline_/AtlasProduction_/g'`"
                if [ -n "$PACMAN_CMD" -a "$PACMAN_CMD_NEW" != "$PACMAN_CMD" ] ; then
                    msgOut WARNING "Failed to execute pacman ${PACMAN_CMD}, trying with pacman ${PACMAN_CMD_NEW}"
                    echo y | pacman ${PACMAN_OPTS} ${PACMAN_CMD_NEW}
                    insttmprc=$?
                    if [ $insttmprc -ne 0 ] ; then
                        msgOut WARNING "Failed to execute pacman ${PACMAN_CMD_NEW}, will create a fake setup"
                        echo "# Main setup file for release ${RELEASE}" > setup.sh
                        insttmprc=$?
                        echo "# Main setup file for release ${RELEASE}" > setup.csh
                        let insttmprc=$insttmprc+$?
                    fi
                fi
            fi
            let instrc=$instrc+$insttmprc
            # DQ2 clients patches
            rm -fr post-setup
            if [ "${PRJTYPE}" == "ext" -a "${PRJNAME}" == "DQ2Clients" ] ; then
                wget --spider --quiet ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                if [ $? -eq 0 ] ; then
                    mkdir post-setup
                    cd post-setup
                    msgOut INFO "Installing DQ2 helper scripts for release ${RELEASE}"
                    wget -r --no-parent -A "*.sh" --quiet -nd ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                    wget -r --no-parent -A "*.csh" --quiet -nd ${DQ2SETUPURL}/${RELEASE}/setup-env.sh
                    cd ..
                else
                    msgOut INFO "No DQ2 helper scripts found for release ${RELEASE}"
                fi
            fi
            SWLOCED="`date +%s`"
            msgOut INFO "Logical area installation completed in `echo $SWLOCED-$SWLOCBD | bc` s"
            if [ $instrc -ne 0 ] ; then
                msgOut ERROR "Logical area installation FAILED"
                msgOut ERROR "`pacman -last 2>&1`"
                OFFENDINGPKG="`pacman -last 2>&1 | grep -i 'has not been installed' | sed 's/\(.*\)\[\(.*\)\].*/\2/' | awk -F':' '{print $NF}'`"
                # Try to fix the broken installations, in case we're not using pacballs
                if [ "$OFFENDINGPKG" != "" -a "$USEPACBALL" != "yes" ] ; then
                    msgOut WARNING "Trying to remove the offending package $OFFENDINGPKG"
                    pacman ${PACMAN_OPTS} -remove ${OFFENDINGPKG}
                    if [ $? -eq 0 ] ; then
                        msgOut INFO "Offending package removed successfully. Now retrying pacman ${PACMAN_OPTS} ${PACMAN_CMD}"
                        pacman ${PACMAN_OPTS} ${PACMAN_CMD}
                        let instrc=$?
                    else
                        msgOut ERROR "Cannot remove the offending package $OFFENDINGPKG"
                        msgOut ERROR "`pacman -last 2>&1`"
                    fi
                fi
                if [ $instrc -ne 0 ] ; then
                    msgOut ERROR "Logical area installation FAILED"
                    msgOut ERROR "`pacman -last 2>&1`"
                    msgOut INFO "Unlocking the installation area"
                    rm -f ${LOCKFILE} ${SNAPN}
                    return $instrc
                fi
            fi
            pacman -clear-snapshots
        fi
    else
        msgOut INFO "Skipping the Logical installation"
    fi
    # Post-install steps
    rm -f $SNAPN
    [ "$TEMPCACHE" == "yes" ] && rm -fr ${SNAPDIR}/${SNAPNAME}*
    shift $#

    # Perform other ATLAS sw specific post-install steps. Exclude external packages, EventView caches and poolcond generations.
    cd "${SWLOG}"
    if [ "$PRJTYPE" == "ext" ] ; then
        if [ "$PRJNAME" == "gcc" ] ; then
            source setup.sh
            setCompiler $GCC_DIR
        elif [ "$PRJNAME" == "DQ2Clients" -a "$GRIDNAME" == "OSG" ] ; then
            DQ2VER="`echo $RELEASE | awk -F '.' '{for (i=1;i<=NF;i++) printf("%02d", $i)}'`"
            if [ "$DQ2VER" -le 134 ] ; then
                msgOut INFO "DQ2 clients v$RELEASE might need patches for this site"
                TMPDQ2PATCH=/tmp/tmp.install.dq2patch.$$
                mkdir $TMPDQ2PATCH
                cd $TMPDQ2PATCH
                wget $OSGDQ2PATCH
                tar xfz `basename $OSGDQ2PATCH`
                if [ -n "$DDMSITE" -a -s "Ls.py-$DDMSITE" ] ; then
                    DQ2PATCHDEST="`\ls -d ${SWPHYS}/DQ2Clients/usr/lib/python*/site-packages/dq2/clientapi/cli/Ls.py 2>/dev/null | tail -n 1`"
                    if [ -n "$DQ2PATCHDEST" ] ; then
                        msgOut INFO "Patching Ls.py with Ls.py-$DDMSITE in $DQ2PATCHDEST"
                        cp -f ${DQ2PATCHDEST} ${DQ2PATCHDEST}.save
                        mv -f Ls.py-$DDMSITE ${DQ2PATCHDEST}
                    else
                        msgOut WARNING "Cannot find Ls.py in DQ2Clients/usr/lib/python*/site-packages/dq2/clientapi/cli"
                    fi
                else
                    msgOut INFO "No patches found for this DQ2 endpoint ($DDMSITE)"
                fi
                cd -
                rm -fr $TMPDQ2PATCH
            fi
        fi
    fi
    if [ "$PRJTYPE" != "ext" -a "${PRJTYPE}" != "eventview" -a "${PRJTYPE}" != "poolcond" -a "${PRJTYPE}" != "dbrelease" -a "${PRJTYPE}" != "tdaq" ] ; then
        if [ "$PRJNAME" == "release" -o "$PRJNAME" == "AtlasRelease" ] ; then
            source setup.sh
            msgOut INFO "Setting up runtime enviroment from ${SITEROOT}/dist/${RELEASE}/Control/AthenaRunTime"
            cd ${SITEROOT}/dist/${RELEASE}/Control/AthenaRunTime/*/cmt
            source setup.sh
        else
            [ -z "$SITEROOT" ] && SITEROOT="$RELPATH"
            if [ -s ${RELPATH}/cmtsite/setup.sh -o -s ${RELPATH}/cmtsite/asetup.sh ] ; then
                if [ -s ${RELPATH}/cmtsite/asetup.sh ] ; then
                    SLC_VER="`echo ${ARCH} | sed -e 's/^.*slc\([0-9]*\).*/\1/g'`"
                    if [ $SLC_VER -lt 6 ] ; then
                        GCC_VER="`echo ${ARCH} | sed -e 's/^.*\(gcc[0-9]*\).*/\1/g' -e 's/43[5-9]$/43/' -e 's/46[0-9]$/46/' -e 's/47[0-9]$/47/'`"
                    else
                        GCC_VER="gcc"
                    fi
                    if [ -f ${RELPATH}/cmtsite/asetup_defaults ] ; then
                        # Modify the asetup defaults
                        msgOut INFO "Adding gcc to the AtlasSetup default file ${RELPATH}/cmtsite/asetup_defaults"
                        sed -i -e "/^${GCC_VER}location/d" -e "/^releasebranch/d" ${RELPATH}/cmtsite/asetup_defaults
                        echo "${GCC_VER}location = ${RELPATH}/AtlasSite/gcc-links" >> ${RELPATH}/cmtsite/asetup_defaults
                        if [ "`basename ${RELPATH} | sed 's/\(rel_\).*/\1/'`" == "rel_" ] ; then
                            echo "releasebranch = \"rel_\"" >> ${RELPATH}/cmtsite/asetup_defaults
                        fi
                        if [ $MAINRELVER -ge 160000 -a $MAINRELVER -le 160300 ] ; then
                            msgOut INFO "Setting testarea = none for releases 16.0.0-16.3.0 in asetup_defaults"
                            sed -i -e "/^testarea/d" ${RELPATH}/cmtsite/asetup_defaults
                            echo "testarea = none" >> ${RELPATH}/cmtsite/asetup_defaults
                        fi
                    else
                        # Create the site setup
                        msgOut INFO "Creating AtlasSetup default file $SITESETUP"
cat > $SITESETUP <<EOD
[default]
${GCC_VER}location = ${RELPATH}/AtlasSite/gcc-links
EOD
                        # Fix cmtsite/asetup.sh
                        sed -i -e "s#^\(source.*AtlasSetup.*\)\( \-\-input.*\)#\1#g" -e "s#^source.*AtlasSetup.*#\0 --input $SITESETUP#" ${RELPATH}/cmtsite/asetup.sh
                    fi
                fi
                if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" -a $SKIPLOGINST -eq 0 ] ; then
                    # Set some additional tags
                    RUNTIME_TAGS=",gcc${REL_COMP},slc${REL_PLAT}"
                    [ "$REL_ARCH" == "i686" ] && RUNTIME_TAGS="${RUNTIME_TAGS},32" || RUNTIME_TAGS="${RUNTIME_TAGS},64"
                    ARUNTIME_TAGS="gcc${REL_COMP} slc${REL_PLAT}"
                    [ "$REL_ARCH" == "i686" ] && ARUNTIME_TAGS="${ARUNTIME_TAGS} 32" || ARUNTIME_TAGS="${ARUNTIME_TAGS} 64"

                    # Setup the release
                    if [ -s ${RELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                        source ${RELPATH}/cmtsite/asetup.sh ${RELEASE} ${PRJNAME} ${PRJOPT} ${ARUNTIME_TAGS}
                    else
                        source ${RELPATH}/cmtsite/setup.sh -tag=${RELEASE},${PRJNAME},${PRJOPT}${RUNTIME_TAGS}
                    fi
                    if [ "$SWLOC" != "$RELLOC" ] ; then
                        # Create the setup-release.sh hub
                        REL_ARCH="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\1/g'`"
                        REL_PLAT="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\2/g'`"
                        REL_COMP="`echo ${ARCH} | sed -e 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\3/g' -e 's/43[5-9]$/43/g' -e 's/46[0-9]$/46/g'`"
                        rm -fr cmtsite
                        mkdir -p cmtsite
cat > cmtsite/setup.sh <<EOSR
CMD_OPT="\$*"
if [ "\$CMD_OPT" = "" ] ; then
    CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT}${RUNTIME_TAGS},runtime"
    echo "Using default options \$CMD_OPT"
fi
source $SITEROOT/cmtsite/setup.sh \$CMD_OPT
EOSR
cat > cmtsite/setup.csh <<EOSR
set CMD_OPT="\$*"
if ( "x\$CMD_OPT" == "x" ) then
    set CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT}${RUNTIME_TAGS},runtime"
    echo "Using default options \$CMD_OPT"
endif
source $SITEROOT/cmtsite/setup.csh \$CMD_OPT
EOSR
cat > cmtsite/asetup.sh <<EOSR
CMD_OPT="\$*"
if [ "\$CMD_OPT" = "" ] ; then
    CMD_OPT="${RELEASE} ${PRJNAME} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
    echo "Using default options \$CMD_OPT"
fi
source $SITEROOT/cmtsite/asetup.sh \$CMD_OPT
EOSR
cat > cmtsite/asetup.csh <<EOSR
set CMD_OPT="\$*"
if ( "x\$CMD_OPT" == "x" ) then
    set CMD_OPT="${RELEASE} ${PRJNAME} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
    echo "Using default options \$CMD_OPT"
endif
source $SITEROOT/cmtsite/asetup.csh \$CMD_OPT
EOSR
cat > setup-release.sh <<EOSR
CMD_OPT="\$*"
MAINRELVER="$MAINRELVER"
if [ "\$CMD_OPT" = "" ] ; then
    if [ -s "$SITEROOT/cmtsite/asetup.sh" -a \$MAINRELVER -ge 160000 ] ; then
        # AtlasSetup
        CMD_OPT="${RELEASE} ${PRJNAME} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
        echo "Using AtlasSetup default options \$CMD_OPT"
    else
        # AtlasLogin
        CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT}${RUNTIME_TAGS},runtime"
        echo "Using AtlasLogin default options \$CMD_OPT"
    fi
fi
if [ -s "$SITEROOT/cmtsite/asetup.sh" -a \$MAINRELVER -ge 160000 ] ; then
    source $SITEROOT/cmtsite/asetup.sh \$CMD_OPT
else
    source $SITEROOT/cmtsite/setup.sh \$CMD_OPT
fi
EOSR
cat > setup-release.csh <<EOSR
set CMD_OPT="\$*"
set MAINRELVER="$MAINRELVER"
if ( "x\$CMD_OPT" == "x" ) then
    if ( -s "$SITEROOT/cmtsite/asetup.sh" && \$MAINRELVER >= 160000 ) then
        set CMD_OPT="${RELEASE} ${PRJNAME} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
        echo "Using default AtlasSetup options \$CMD_OPT"
    else
        set CMD_OPT="-tag=${RELEASE},${PRJNAME},${PRJOPT}${RUNTIME_TAGS},runtime"
        echo "Using default AtlasLogin options \$CMD_OPT"
    endif
endif
if ( -s "$SITEROOT/cmtsite/asetup.sh" && \$MAINRELVER >= 160000 ) then
    source $SITEROOT/cmtsite/asetup.csh \$CMD_OPT
else
    source $SITEROOT/cmtsite/setup.csh \$CMD_OPT
endif
EOSR
                        grep -v "source $PWD/setup-release.sh"  setup.sh | \
                                grep -v "source $SITEROOT/cmtsite/setup.sh"  > setup.sh.tmp
                        grep -v "source $PWD/setup-release.csh" setup.csh | \
                                grep -v "source $SITEROOT/cmtsite/setup.csh" > setup.csh.tmp
                        echo "source $PWD/setup-release.sh \$*"  >> setup.sh.tmp
                        echo "source $PWD/setup-release.csh \$*"  >> setup.csh.tmp
                        \mv -f setup.sh.tmp setup.sh
                        \mv -f setup.csh.tmp setup.csh
                    fi
                    if [ $SKIPPHYSINST -eq 0 ] ; then
                        # Compatibility patches
                        DETECTED_DIST="`lsb_release -d | cut -d: -f 2 | sed 's/[^[:alpha:]*]//'`"
                        # SL4 to SL5 patches
                        COMPATDIST="`echo $DETECTED_DIST | egrep 'Scientific Linux .* 5\..*|CentOS .* 5\..*|Red Hat.* 5\..*'`"
                        # SL5 runtime patches
                        SL5RTDIST="`echo $DETECTED_DIST | egrep 'SUSE .* 10.*'`"
                        RELDETARCH="`echo ${ARCH} | sed 's/.*_\(slc[0-9]\)_.*/\1/'`"
                        if [ "$RELDETARCH" == "slc3" -o "$RELDETARCH" == "slc4" ] ; then
                            msgOut INFO "We are installing $RELDETARCH software. Checking if we need to install the SL5 compatibility patches."
                            if [ "$COMPATDIST" != "" ] ; then
                                msgOut INFO "The detected architecture might need patches: `echo $COMPATDIST | cut -d: -f 2-`"
                            elif [ "$DETECTED_DIST" != "" ] ; then
                                msgOut INFO "The detected architecture does not need patches: $DETECTED_DIST"
                            else
                                msgOut INFO "Unable to detect the system architecture"
                            fi
                        else
                            COMPATDIST=""
                            msgOut INFO "You are trying to install a $RELDETARCH software. Checking if we need to install patches."
                            if [ "$SL5RTDIST" != "" ] ; then
                                msgOut INFO "The detected architecture needs the SL5 runtime patches: $DETECTED_DIST"
                            else
                                msgOut INFO "The detected architecture does not need patches: $DETECTED_DIST"
                            fi
                        fi
                        if [ "$COMPATDIST" != "" -a "$COMPATPATCH" != "" ] ; then
                            LASTAL="`\ls -d $SITEROOT/AtlasLogin/* | sed 's#.*AtlasLogin-\([0-9]*\)-\([0-9]*\)-\([0-9]*\)#\1\2\3#' | sort | tail -n 1`"
                            LASTAS="`\ls -d $SITEROOT/AtlasSettings/* | sed -e 's#.*AtlasSettings[-/]\([0-9]*-*\)\([0-9]*-*\)\([0-9]*\)#\1\2\3#' -e 's#v#0-#' -e 's#r#-#' | sort | tail -n 1 | awk -F'-' '{for (i=1;i<=NF;i++) printf "%02d",$i}'`"
                            LASTSLC4C="`\ls -d $SITEROOT/external/slc4compat 2>/dev/null`"
                            LASTACPP="`cat $SITEROOT/AtlasCore/${RELEASE}/External/PlatformPolicy/cmt/version.cmt 2>/dev/null | sed 's#.*PlatformPolicy-\([0-9]*\)-\([0-9]*\)-\([0-9]*\)#\1\2\3#'`"
                            LASTACSLC4C="`cat $SITEROOT/AtlasCore/${RELEASE}/External/SLC4_Compat/cmt/version.cmt 2>/dev/null | sed 's#.*SLC4_Compat-\([0-9]*\)-\([0-9]*\)-\([0-9]*\)#\1\2\3#'`"
                            [ "$LASTACPP" == "" ] && LASTACPP=0
                            [ "$LASTACSLC4C" == "" ] && LASTACSLC4C=0
                            if [ $LASTAL -lt 318 -o $LASTAS -lt 30220 -o "$LASTSLC4C" == "" -o $LASTACPP -lt 3 -o $LASTACSLC4C -lt 3 ] ; then
                                [ $LASTAL -lt 318 ] && msgOut INFO "Found AtlasLogin-`echo $LASTAL | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, which is older than 00-03-18. Applying the SL4 to SL5 patches"
                                [ $LASTAS -lt 30220 ] && msgOut INFO "Found AtlasSettings-`echo $LASTAS | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, which is older than 03-02-20. Applying the SL4 to SL5 patches"
                                [ "$LASTSLC4C" == "" ] && msgOut INFO "No slc4compat package found. Applying the SL4 to SL5 patches"
                                [ $LASTACPP -lt 3 ] && msgOut INFO "Found PlatformPolicy `echo $LASTACPP | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`. Applying the SL4 to SL5 patches"
                                [ $LASTACSLC4C -lt 3 ] && msgOut INFO "Found SLC4_Compat `echo $LASTACSLC4C | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`. Applying the SL4 to SL5 patches"
                                cd $SITEROOT
                                prc=0
                                for f in ${COMPATPATCH[@]}; do
                                    rm -f ${f}
                                    wget ${COMPATURL}/${f}
                                    let prc=$prc+$?
                                done
                                if [ $prc -eq 0 ] ; then
                                    chmod +x ${COMPATPATCH[0]}
                                    ./${COMPATPATCH[0]} $RELEASE
                                    [ $? -eq 0 ] && msgOut INFO "Patch successful" || msgOut ERROR "Patch Failed"
                                else
                                    msgOut ERROR "Cannot get the patch files from $COMPATURL"
                                fi
                                for f in ${COMPATPATCH[@]}; do rm -f $f; done
                                cd -
                            else
                                msgOut INFO "Found AtlasLogin-`echo $LASTAL | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, AtlasSettings-`echo $LASTAS | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, slc4compat, PlatformPolicy `echo $LASTACPP | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, SLC4_Compat `echo $LASTACSLC4C | sed 's#\(..\)\(..\)\(..\)#\1-\2\-\3#'`, no need to apply the SL4 to SL5 patches"
                            fi
                        fi

                        # SL5 runtime patches
                        if [ "$SL5RTDIST" != "" -a "$SL5RTPATCH" != "" ] ; then
                            PYTHON25="`ls -d $SITEROOT/sw/lcg/external/Python/2.5* 2>/dev/null | tail -n 1`"
                            if [ -n "$PYTHON25" ] ; then
                                TGTPATH="`\ls -d $SITEROOT/$PRJNAME/$RELEASE/InstallArea/i686-* | sort | tail -n 1`"
                                if [ -n "$TGTPATH" ] ; then
                                    cd $TGTPATH
                                    msgOut INFO "Storing patches in $PWD and `dirname $PWD`/python"
                                    prc=0
                                    for f in ${SL5RTPATCH[@]}; do
                                        rm -f ${f}
                                        wget ${SL5RTURL}/${f}
                                        let prc=$prc+$?
                                        if [ $prc -eq 0 ] ; then
                                            tar xvfz ${f} | grep so$ | awk '{print $NF}' | while read pf; do ln -sf ../`basename $PWD`/$pf ../python; done
                                            let prc=$prc+$?
                                        fi
                                        rm -f $f
                                    done
                                    [ $prc -eq 0 ] && msgOut INFO "Patch successful" || msgOut ERROR "Patch Failed"
                                    cd -
                                else
                                    msgOut INFO "No directory called $SITEROOT/$PRJNAME/$RELEASE/InstallArea/i686-* found. Will not apply patches."
                                fi
                            else
                                msgOut INFO "No SL5 runtime patches applied since this release does not have python 2.5"
                            fi
                        fi
                    fi
                elif [ "$PRJTYPE" != "tdaq" ] ; then
                    if [ $SKIPPHYSINST -eq 0 ] ; then
                        # Set some additional tags
                        RUNTIME_TAGS=",gcc${REL_COMP},slc${REL_PLAT}"
                        [ "$REL_ARCH" == "i686" ] && RUNTIME_TAGS="${RUNTIME_TAGS},32" || RUNTIME_TAGS="${RUNTIME_TAGS},64"
                        ARUNTIME_TAGS="gcc${REL_COMP} slc${REL_PLAT}"
                        [ "$REL_ARCH" == "i686" ] && ARUNTIME_TAGS="${ARUNTIME_TAGS} 32" || ARUNTIME_TAGS="${ARUNTIME_TAGS} 64"

                        # Check if the patch number is in AtlasLogin and add it if needed
                        if [ "$PRJTYPE" == "analysis" -a "${REQPRJNAME}" != "AtlasOffline" ] ; then
                            RELBASE="`echo $RELEASE | cut -d. -f 1-4`"
                        else
                            RELBASE="`echo $RELEASE | cut -d. -f 1-3`"
                        fi
                        if [ -s "$RELPATH/cmtsite/asetup.sh" -a $MAINRELVER -ge 160000 ] ; then
                            msgOut INFO "Checking the AtlasLogin requirements (source ${RELPATH}/cmtsite/asetup.sh ${RELBASE} ${REQPRJNAME} ${PRJOPT} ${ARUNTIME_TAGS})"
                            source ${RELPATH}/cmtsite/asetup.sh ${RELBASE} ${REQPRJNAME} ${PRJOPT} ${ARUNTIME_TAGS}
                        else
                            msgOut INFO "Checking the AtlasLogin requirements (source ${RELPATH}/cmtsite/setup.sh -tag=${RELBASE},${REQPRJNAME},${PRJOPT}${RUNTIME_TAGS})"
                            source ${RELPATH}/cmtsite/setup.sh -tag=${RELBASE},${REQPRJNAME},${PRJOPT}${RUNTIME_TAGS}
                            [ "$AtlasVersion" == "not_numbered" ] && msgOut ERROR "${REQPRJNAME} ${RELBASE} not found. Probably wrong installation definition."
                        fi
                        SITEROOT="`getRWpath ${SITEROOT}`"

                        for ATLASLOGINREQ in `\find $SITEROOT/AtlasLogin -name "requirements"`; do
                            msgOut INFO "Checking $ATLASLOGINREQ"
                            grep "$RELEASE[^0-9]" $ATLASLOGINREQ 2>&1 > /dev/null
                            if [ $? -ne 0 ] ; then
                                ADD_TO_AL="y"
                            else
                                ADD_TO_AL="n"
                                if [ -s "${ATLASLOGINREQ}.orig" ] ; then
                                    grep "$RELEASE[^0-9]" ${ATLASLOGINREQ}.orig 2>&1 > /dev/null
                                    if [ $? -ne 0 ] ; then
                                        msgOut INFO "Will re-use ${ATLASLOGINREQ}.orig"
                                        \cp -f ${ATLASLOGINREQ}.orig ${ATLASLOGINREQ}
                                        BACKUP_AL="n"
                                        ADD_TO_AL="y"
                                    fi
                                fi
                            fi
                            if [ "$ADD_TO_AL" == "y" ] ; then
                                msgOut INFO "Adding $RELEASE to the AtlasLogin requirements ($ATLASLOGINREQ)"
                                LATESTPATCH="`grep ".*$RELBASE\..*\\"$RELBASE\..*\\"" $ATLASLOGINREQ | awk '{print $1}' | grep ^$RELBASE | tail -n 1`"
                                if [ -z "$LATESTPATCH" ] ; then
                                    msgOut WARNING "No patch series detected for $RELEASE, will not change the AtlasLogin requirements ($ATLASLOGINREQ)"
                                else
                                    if [ "$BACKUP_AL" == "y" ] ; then
                                        msgOut INFO "Backing up ${ATLASLOGINREQ} into ${ATLASLOGINREQ}.orig"
                                        mv -f ${ATLASLOGINREQ} ${ATLASLOGINREQ}.orig
                                    fi
                                    ALBAK="y"
                                    AWKCMD="{bs=\"\\\ \"; gsub(/ *\$/,\"\",bs); bss=sprintf(\" %s\",bs); if (/$LATESTPATCH.*\"$LATESTPATCH\"/ && !/\\\/) {printf \"%s%s\n\", \$0, bss;} else {print \$0;} if (/$LATESTPATCH.*\"$LATESTPATCH\"/) {gsub(/$LATESTPATCH/,\"$RELEASE\",\$0);print \$0;}}"
                                    cat ${ATLASLOGINREQ}.orig | awk "$AWKCMD" > ${ATLASLOGINREQ}
                                fi
                            else
                                msgOut INFO "$RELEASE already present in the AtlasLogin requirements ($ATLASLOGINREQ)"
                            fi
                            if [ "${PRJTYPE}" == "analysis" ] ; then
                                msgOut INFO "Checking the analysis project parameters"
                                grep -q "${PRJNAME}.*phyana" $ATLASLOGINREQ
                                if [ $? -ne 0 ] ; then
                                    if [ -z "$ALBAK" ] ; then
                                        cp -f ${ATLASLOGINREQ} ${ATLASLOGINREQ}.orig
                                        ALBAK=y
                                    fi
                                    msgOut INFO "Adding the analysis project is_phyana parameter for ${PRJNAME}"
                                    sed -i "/macro.*is_phyana/ a\      $PRJNAME        \"_phyana\" \\\\" ${ATLASLOGINREQ}
                                else
                                    msgOut INFO "Analysis project is_phyana parameter already present for ${PRJNAME}"
                                fi
                                grep -q "${PRJNAME}.*${PRJNAME}" $ATLASLOGINREQ
                                if [ $? -ne 0 ] ; then
                                    msgOut INFO "Adding the analysis project ATLAS_PHYS_NAME parameter for ${PRJNAME}"
                                    if [ -z "$ALBAK" ] ; then
                                        cp -f ${ATLASLOGINREQ} ${ATLASLOGINREQ}.orig
                                        ALBAK=y
                                    fi
                                    sed -i "/macro.*ATLAS_PHYS_NAME/ a\          $PRJNAME           \"$PRJNAME\" \\\\" ${ATLASLOGINREQ}
                                else
                                    msgOut INFO "Analysis project ATLAS_PHYS_NAME parameter already present for ${PRJNAME}"
                                fi
                            fi
                            \find $ATLASLOGINREQ -maxdepth 1 -type d ! -perm -a+r -exec chmod a+rX {} \;
                        done
                    fi
                    [ -n "$SITEROOT" ] && SITEROOT="`getRWpath ${SITEROOT}`"
                    if [ -d $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt ] ; then
                        msgOut INFO "Setting up runtime enviroment from $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime"
                        cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                        if [ ! -s setup.sh ] ; then
                            msgOut WARNING "No setup file found. Trying to configure..."
                            cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}Release/cmt
                            cmt -quiet br - 'cmt -quiet -no_cleanup config'
                            cd $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                            if [ ! -s setup.sh ] ; then
                                msgOut ERROR "Cannot configure the package"
                            else
                                source setup.sh
                            fi
                        else
                            source setup.sh
                        fi
                    else
                        msgOut INFO "Cannot setup runtime enviroment from $SITEROOT/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime"
                    fi
                fi
            else
                msgOut ERROR "Cannot find setup file ${RELPATH}/cmtsite/setup.sh or ${RELPATH}/cmtsite/asetup.sh"
                let instrc=$instrc+1
            fi
        fi
    fi

    # End-of-run tasks
    if [ $instrc -eq 0 ] ; then
        if [ "$PRJTYPE" != "ext" -a "$PRJTYPE" != "eventview" -a "${PRJTYPE}" != "poolcond" -a "${PRJTYPE}" != "dbrelease" -a "${PRJTYPE}" != "tdaq" -a $SKIPPHYSINST -eq 0 ] ; then
            [ "`which SealPluginRefresh 2>/dev/null`" != "" ] && SealPluginRefresh
            [ "`which cmt 2>/dev/null`" != "" ] && cmt build library_links
        fi
        # Set the required environment variables in the setup scripts
        if [ $SKIPLOGINST -eq 0 ] ; then
            cd "${SWLOG}"
            for setvar in `echo $SETENV | sed 's/,/ /g'`; do
                msgOut INFO "Setting $setvar in $PWD/setup.sh"
                VAREXPORTSH="export $setvar"
                VAREXPORTCSH="setenv `echo $setvar | sed 's/=/ /g'`"
                grep -v "$VAREXPORTSH"  setup.sh > setup.sh.tmp
                grep -v "$VAREXPORTCSH" setup.csh > setup.csh.tmp
                echo "$VAREXPORTSH"  >> setup.sh.tmp
                echo "$VAREXPORTCSH" >> setup.csh.tmp
                \mv -f setup.sh.tmp setup.sh
                \mv -f setup.csh.tmp setup.csh
            done
            cd ${SWPHYS}
        fi
    fi

    # Set the correct file permissions for the sw areas
    case `whoami` in
        usatlas*) msgOut INFO "This is an OSG site with static accounts. No further action required"
            ;;
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts"
            msgOut INFO "Preparing to set write permissions to group \"`id -gn`\" on ${SWPHYS}"
            msgOut INFO "Preparing to set write permissions to group \"`id -gn`\" on ${SWLOG}"
            CHMOD_OPTS="g+rw,o+r"
            if [ "$DUMPTAGS" != "" ] ; then
                # Check if we are running in AFS
                if [ "`echo $DUMPTAGS | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
                    # Check if we are already in the rw path 
                    if [ "`echo $DUMPTAGS | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
                        DUMPTAGS="`echo $DUMPTAGS | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
                    fi
                fi
                WHOAMI="`whoami`"
                DUMPTAGSFILE="`find ${DUMPTAGS} -user ${WHOAMI} ! -perm -g+rw`"
                if [ "$DUMPTAGSFILE" != "" ] ; then
                    msgOut INFO "Setting group write permissions to ${DUMPTAGS}"
                    chmod g+rw $DUMPTAGS 2>/dev/null
                    [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${DUMPTAGS}"
                fi
            fi
            ;;
        *) msgOut INFO "This site is configured for SGM static accounts. No further action required"
            ;;
    esac
    [ "$CHMOD_OPTS" != "" ] && CHMOD_OPTS="o-w,a+X,$CHMOD_OPTS" || CHMOD_OPTS="o-w,a+X"
    if [ $SKIPPHYSINST -eq 0 ] ; then
        msgOut INFO "Setting permissions in ${SWPHYS} to $CHMOD_OPTS"
        find ${SWPHYS} -user `whoami` ! -type l ! -perm -$CHMOD_OPTS -exec chmod $CHMOD_OPTS "{}" \; -exec ls -ld "{}" \;
        [ $? -ne 0 ] && msgOut ERROR "Cannot change permissions in ${SWPHYS}"
    fi
    if [ $SKIPLOGINST -eq 0 ] ; then
        if [ "$SWLOC" != "${RELLOC}" ] ; then
            msgOut INFO "Setting permissions in ${SWLOG} to $CHMOD_OPTS"
            find ${SWLOG} -user `whoami` ! -type l ! -perm -$CHMOD_OPTS -exec chmod $CHMOD_OPTS "{}" \; -exec ls -ld "{}" \;
            [ $? -ne 0 ] && msgOut ERROR "Cannot change permissions in ${SWLOG}"
        fi
    fi

    # End of post-processing
    if [ $instrc -eq 0 ] ; then
        # If we are using AFS, relocate the release to the correct path
        [ $SKIPPHYSINST -eq 0 -a "$AFSRELLOC" != "" ] && relocateRelease $SWPHYS $AFSRELLOC $SWPHYS
        [ $SKIPLOGINST -eq 0  -a "$AFSRELLOC" != "" ] && relocateRelease $SWPHYS $AFSRELLOC $SWLOG
        [ $SKIPLOGINST -eq 0  -a "$AFSLOC"    != "" ] && relocateRelease $SWLOG $AFSLOC $SWLOG

        # Release the physical installation volume, if possible
        if [ $SKIPPHYSINST -eq 0 -a "$AFSRELLOC" != "" ] ; then
            AFSRELEASE="`which afs_release 2>/dev/null`"
            if [ "$AFSRELEASE" != "" ] ; then
                AFSMP1="`isAFSmountpoint ${AFSRELLOC}`"
                AFSMP2="`isAFSmountpoint ${RELLOC}`"
                if [ -n "$AFSMP1" -o -n "$AFSMP2" ] ; then
                    [ -f ${LOCKFILE} ] && rm -f ${LOCKFILE}
                    msgOut INFO "Releasing AFS volume: $AFSRELEASE ${AFSRELLOC}"
                    $AFSRELEASE "${AFSRELLOC}"
                    afsrelrc=$?
                    [ $afsrelrc -ne 0 ] && msgOut ERROR "Cannot release AFS volume. Error code: $afsrelrc" || msgOut INFO "AFS volume released successfully"
                    let instrc=$instrc+$afsrelrc
                else
                    msgOut WARNING "${AFSRELLOC} and ${RELLOC} are not AFS volumes, will not try to release them"
                fi
            else
                msgOut WARNING "No afs_release command found"
                msgOut WARNING "PATH=$PATH"
            fi
        fi

        msgOut INFO "Installation OK"
    fi

    msgOut INFO "Unlocking the installation area"
    [ -f ${LOCKFILE} ] && rm -f ${LOCKFILE}
    cd ${TOPDIR}
    return $instrc
}


validate() {
    let validrc=0
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    /usr/bin/env | grep '=' | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Start the validation
    SWPHYS=${RELLOC}
    SWLOG=${SWLOC}
    if [ "${SWPATH}" != "" ] ; then
        SWPHYS="$SWPATH"
        SWLOG="$SWPATH"
    fi

    # Main release path
    [ -n "${MAINRELPATH}" ] && SWRELPATH="${MAINRELPATH}" || SWRELPATH="${SWLOC}"

    # Fix SWRELPATH for special cases
    if [ ! -d $SWRELPATH ] ; then 
        msgOut INFO "Software release path not found: $SWRELPATH"
        ARCHTXT="`echo $SWRELPATH | awk -F'/' '{print $(NF-1)}'`"
        SWRELPATHNEW="`echo $SWRELPATH | sed "s#$ARCHTXT/##"`"
        if [ -d "$SWRELPATHNEW" ] ; then
            SWRELPATH="$SWRELPATHNEW"
            msgOut INFO "Will use path $SWRELPATH"
        else
            msgOut WARNING "Software release path not found: $SWRELPATHNEW"
        fi
    fi

    # Start testing
    cd ${TOPDIR}
    TESTDIR=${TOPDIR}/kvtest_$$
    mkdir "$TESTDIR"
    cd "$TESTDIR"
    if [ "$VALEXE" != "" ] ; then
        # Run an external validation script
        msgOut INFO "Setting up the release from ${SWLOG}"
        source ${SWLOG}/setup.sh
        if [ -s "$INSTALLER_HOME/$VALEXE" ] ; then
            msgOut INFO "Executing the external validation exe $INSTALLER_HOME/$VALEXE"
            chmod +x $INSTALLER_HOME/`echo $VALEXE | awk '{print $1}'`
            $INSTALLER_HOME/$VALEXE $PRJNAME
            validrc=$?
        else
            msgOut INFO "Executing $VALEXE"
            eval $VALEXE
            validrc=$?
        fi
    else
        if [ "${PRJTYPE}" == "ext" ] ; then
            # Let's run a generic setup and print the environment + some other commands
            msgOut INFO "Setting up the release from ${SWLOG}"
            source ${SWLOG}/setup.sh
            validrc=$?
            msgOut INFO "Printing the environment"
            msgOut INFO "`printenv`"
            [ "`which lcg-cp 2>/dev/null`"  != "" ] && msgOut INFO "lcg-cp:  `which lcg-cp`"
            [ "`which lcg-cr 2>/dev/null`"  != "" ] && msgOut INFO "lcg-cr:  `which lcg-cr`"
            [ "`which lcg-del 2>/dev/null`" != "" ] && msgOut INFO "lcg-del: `which lcg-del`"
        elif [ "${PRJTYPE}" == "analysis" ] ; then
            if [ -d "${SWPHYS}/${PRJNAME}/${RELEASE}" ] ; then
                msgOut INFO "Project directory ${SWPHYS}/${PRJNAME}/${RELEASE} found"
            else
                msgOut ERROR "No directory ${SWPHYS}/${PRJNAME}/${RELEASE} found"
                validrc=1
            fi
        elif [ "${PRJTYPE}" == "tdaq" ] ; then
            if [ -d "${SWPHYS}/${PRJNAME}/${ATLASRELEASE}" ] ; then
                msgOut INFO "Project directory ${SWPHYS}/${PRJNAME}/${ATLASRELEASE} found"
            else
                msgOut ERROR "No directory ${SWPHYS}/${PRJNAME}/${ATLASRELEASE} found"
                validrc=1
            fi
        elif [ "${PRJTYPE}" == "poolcond" ] ; then
            if [ -s "$SWLOG/PoolFileCatalog.xml" ] ; then
                python -c "import xml.dom.minidom;xml.dom.minidom.parse('$SWLOG/PoolFileCatalog.xml')"
                validrc=$?
                if [ $validrc -eq 0 ] ; then
                    msgOut INFO "$SWLOG/PoolFileCatalog.xml found"
                    VALEXE="`which FClistPFN 2>/dev/null`"
                    if [ "$VALEXE" == "" -a "$RELSETUP" != "" ] ; then
                        MAXREL=$((${#RELSETUPLIST[@]}-1))
                        if [ ${MAXREL} -ge 0 ] ; then
                            for r in `seq $MAXREL -1 0`; do
                                msgOut WARNING "No FClistPFN found. Trying to setup the latest ATLAS release with ${RELSETUPLIST[$r]}"
                                eval ${RELSETUPLIST[$r]}
                                VALEXE="`which FClistPFN 2>/dev/null`"
                                if [ "$VALEXE" != "" ] ; then
                                    msgOut INFO "FClistPFN found in release $AtlasVersion"
                                    break
                                fi
                            done
                        fi
                    fi
                    if [ "$VALEXE" != "" ] ; then
                        PFNLIST="$SWLOG/PoolFileCatalog.$$.pfnlist"
                        FClistPFN -u file:$SWLOG/PoolFileCatalog.xml > $PFNLIST
                        validrc=$?
                        if [ $validrc -eq 0 ] ; then
                            PFCS="`cat $PFNLIST | wc -l`"
                            if [ $PFCS -gt 0 ] ; then
                                msgOut INFO "$PFCS entries found in $SWLOG/PoolFileCatalog.xml"
                                validrc=0
                            else
                                msgOut ERROR "No entries found in $SWLOG/PoolFileCatalog.xml"
                                validrc=30
                            fi
                            INVALIDPFCS="`cat $PFNLIST | grep ^srm | wc -l`"
                            if [ $INVALIDPFCS -gt 0 ] ; then
                                msgOut ERROR "$INVALIDPFCS PFC entries using srm protocol, invalid PFC"
                                validrc=40
                            fi
                            INVALIDPFCS="`cat $PFNLIST | egrep -v '^dcap:/|^dcache:/|^file:/|rfio:/|root:/|^/' | wc -l`"
                            if [ $INVALIDPFCS -gt 0 ] ; then
                                msgOut ERROR "$INVALIDPFCS PFC entries not using dcap:/, dcache:/, file:/, rfio:/, root:/ or standard path protocol, invalid PFC"
                                validrc=50
                            fi
                        fi
                        rm -f $PFNLIST
                    else
                        msgOut ERROR "No FClistPFN found"
                        validrc=20
                    fi
                else
                    msgOut ERROR "Cannot parse $SWLOG/PoolFileCatalog.xml"
                fi
            else
                msgOut ERROR "Cannot find $SWLOG/PoolFileCatalog.xml or the file is empty"
                validrc=10
            fi
        else
            # Main release version
            MAINRELVER="`echo $RELEASE | awk -F "." '{for (i=1;i<=3;i++) ver=sprintf("%s%02d",ver,$i)}END{print int(ver)}'`"

            # Let's run KitValidation
            if [ "${PRJNAME}" == "AtlasRelease" -o "${PRJNAME}" == "release" ] ; then
                KVBUILD_OPTS=""
            else
                RELSERIAL="`echo $RELEASE | cut -d "." -f 1-3 | awk -F. '{printf "%d",$1; for(i=2;i<=NF;i++) printf "%03d", $i;}'`"
                if [ "${PRJNAME}" == "AtlasOffline" -a $RELSERIAL -lt 13000030 -a $RELSERIAL -gt 0 ] ; then
                    KVBUILD_OPTS="--project AtlasProduction"
                else
                    KVBUILD_OPTS="--project ${PRJNAME}"
                fi
            fi
            [ "$T_POST" == "yes" ] && msgOut INFO "KV posting enabled"
            [ "$KVPOSTTAG" != "" ] && msgOut INFO "Using GKV tag $KVPOSTTAG"
            [ "${PRJTYPE}" == "bugfix" -o "${PRJTYPE}" == "dev" -o "${PRJTYPE}" == "p1nightly" ] && KVRELTYPE=":${PRJTYPE}" || KVRELTYPE=""
            [ "${PRJTYPE}" == "p1patch" ] && KVRELTYPE=":p1" || KVRELTYPE=""
            [ "${PRJTYPE}" == "t0patch" ] && KVRELTYPE=":t0" || KVRELTYPE=""
            [ "${PRJTYPE}" == "eventview" ] && KVRELTYPE=":ev" || KVRELTYPE=""
            KVRELBASE="`echo $RELEASE | cut -d "." -f 1-3`"
            if [ "$DEBUG" == "yes" ] ; then
                msgOut DEBUG "PATH=${PATH}"
                msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
                msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
            fi
            [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
            msgOut INFO "Starting validation of release $RELEASE"

            # Override the DB release if needed
            if [ "$DBREL" != "" ] ; then
                if [ -d "$SITEROOT/DBRelease/$DBREL" ] ; then
                    msgOut INFO "DBRelease $DBREL found in $SITEROOT/DBRelease"
                elif [ -n "$DBAREA" -a -d "$DBAREA/DBRelease/$DBREL" ] ; then
                    msgOut INFO "DBRelease $DBREL found in $DBAREA/DBRelease"
                else
                    if [ -n "$DBAREA" ] ; then
                        LATEST_DBREL_VER="`ls $DBAREA/DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1 | awk '{print $2}'`"
                    else
                        LATEST_DBREL_VER="`ls $SITEROOT/DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1 | awk '{print $2}'`"
                    fi
                    [ -z "$LATEST_DBREL_VER" ] && LATEST_DBREL_VER="current"
                    msgOut WARNING "Cannot find DBRelease $DBREL, will try to use the latest version ($LATEST_DBREL_VER)"
                    DBREL="$LATEST_DBREL_VER"
                fi
                [ $MAINRELVER -lt 160000 ] && export DBRELEASE_OVERRIDE=$DBREL || ASETUP_DBOPT="--dbrelease=$DBREL "
                msgOut INFO "Using DBRelease $DBREL"
            fi

            # Set the DB area
            if [ -n "$DBAREA" ] ; then
                [ $MAINRELVER -lt 160000 ] && export ATLAS_DB_AREA=$DBAREA || ASETUP_DBOPT="${ASETUP_DBOPT}--dbarea=$DBAREA "
                msgOut INFO "Using DB area $DBAREA"
            fi

            KVBASEDIR="${KVRELBASE}"
            msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidation"
            pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidation
            if [ $? -ne 0 ] ; then
                msgOut WARNING "Failed to get the KV setup from ${LCGCACHE}:${KVBASEDIR}/KitValidation"
                KVBASEDIR="generic"
                msgOut WARNING "Trying with pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidation"
                pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidation
                let validrc=$validrc+$?
            fi
            msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidationPatches"
            pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidationPatches
            [ $? -eq 0 ] && source setup.sh

            # Use CMTUSERCONTEXT to overcome compilation problems with SL5 binaries on SL6
            [ -z "$CMTUSERCONTEXT" ] && export CMTUSERCONTEXT=/cvmfs/atlas.cern.ch/repo/tools/slc6/cmt

            [ "$PRJTYPE" == "analysis" -a "${REQPRJNAME}" != "AtlasOffline" ] && KVRELBASE="`echo $RELEASE | cut -d "." -f 1-4`"
            if [ "$KVBUILD_OPTS" != "" -a $validrc -eq 0 ] ; then
                REL_ARCH="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\1/g'`"
                REL_PLAT="`echo ${ARCH} | sed 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\2/g'`"
                REL_COMP="`echo ${ARCH} | sed -e 's/^[_ ]\(.*\)_slc\([0-9]\)_gcc\([0-9]*\)/\3/g' -e 's/43[5-9]$/43/g' -e 's/46[0-9]$/46/g'`"
                # Set some additional tags
                RUNTIME_TAGS=",gcc${REL_COMP},slc${REL_PLAT}"
                [ "$REL_ARCH" == "i686" ] && RUNTIME_TAGS="${RUNTIME_TAGS},32" || RUNTIME_TAGS="${RUNTIME_TAGS},64"
                ARUNTIME_TAGS="gcc${REL_COMP} slc${REL_PLAT}"
                [ "$REL_ARCH" == "i686" ] && ARUNTIME_TAGS="${ARUNTIME_TAGS} 32" || ARUNTIME_TAGS="${ARUNTIME_TAGS} 64"

                if [ -s ${SWRELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                    SETUPCMD="source ${SWRELPATH}/cmtsite/asetup.sh "
                else
                    SETUPCMD="source ${SWRELPATH}/cmtsite/setup.sh -tag="
                fi

                if [ "${PRJTYPE}" == "p1nightly" ] ; then
                    msgOut INFO "Setting up the point1 nightly release from $PWD"
                    if [ -s ${SWRELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                        msgOut INFO "${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
                        eval ${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS} runtime
                    else
                        msgOut INFO "${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS},runtime"
                        eval ${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS},runtime
                    fi
                elif [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" -o "$PRJTYPE" == "t0patch" -o "${PRJTYPE}" == "eventview" -o "${PRJTYPE}" == "analysis" -a "$PRJTYPE" != "tdaq" ] ; then
                    msgOut INFO "Setting up the release from $PWD"
                    if [ -s ${SWRELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                        msgOut INFO "${SETUPCMD}${ASETUP_DBOPT}${REQPRJNAME} ${KVRELBASE} ${PRJOPT} ${ARUNTIME_TAGS}"
                        eval ${SETUPCMD}${ASETUP_DBOPT}${REQPRJNAME} ${KVRELBASE} ${PRJOPT} ${ARUNTIME_TAGS}
                    else
                        msgOut INFO "${SETUPCMD}${REQPRJNAME},${KVRELBASE},${PRJOPT}${RUNTIME_TAGS},runtime"
                        eval ${SETUPCMD}${REQPRJNAME},${KVRELBASE},${PRJOPT}${RUNTIME_TAGS},runtime
                    fi
                else
                    msgOut INFO "Setting up the release from $PWD"
                    if [ -s ${SWRELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                        msgOut INFO "${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS}"
                        eval ${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS}
                    else
                        msgOut INFO "${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS}"
                        eval ${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS}
                    fi
                    # Extend the CMTEXTRATAGS if we are on SL6 equivalent machines
                    #if [ "`hostEquiv`" == "host-slc6" ] ; then
                    #    msgOut INFO "Extending CMTEXTRATAGS with host-slc6 for SL6 equivalent plaforms"
                    #    export CMTEXTRATAGS="${CMTEXTRATAGS},host-slc6"
                    #fi
                fi
                if [ "${PRJTYPE}" == "patch" -o "${PRJTYPE}" == "p1patch" -o "$PRJTYPE" == "t0patch" ] ; then
                    msgOut INFO "Using patch release $RELEASE from $PWD"
                    unset CMTPATH
                    if [ "$SWLOC" == "$SWRELPATH" ] ; then
                        cd ${SITEROOT}/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                    else
                        cd ${SWLOC}/${PRJNAME}/${RELEASE}/${PRJNAME}RunTime/cmt
                    fi
                    source setup.sh
                    validrc=$?
                    if [ $validrc -eq 0 ] ; then
                        msgOut INFO "Patch release ${RELEASE} setup complete"
                        msgOut INFO "CMTPATH=${CMTPATH}"
                        export AtlasPatchVersion=${RELEASE}
                        export AtlasVersion=${RELEASE}
                    else
                        msgOut ERROR "Cannot setup patch release ${RELEASE}"
                    fi
                    cd -
                elif [ "${PRJTYPE}" == "eventview" ] ; then
                    msgOut INFO "Using EventView version $RELEASE from $PWD"
                    setupDev "-tag=${REQPRJNAME},${KVRELBASE}${RUNTIME_TAGS},groupArea,runtime"
                    #validrc=$?
                    validrc=1
                elif [ "${PRJTYPE}" == "analysis" ] ; then
                    msgOut INFO "Skipping additional setup since we are using an analysis project"
                elif [ "${PRJTYPE}" == "tdaq" ] ; then
                    msgOut INFO "Skipping additional setup since we are using tdaq"
                else
                    msgOut INFO "Using plain release $RELEASE from $PWD"
                    [ "`which pacman 2>/dev/null`" == "" ] && setupPacman
                    msgOut INFO "Executing pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidationPyJTPatches"
                    pacman $PACMAN_OPTS -get ${LCGCACHE}:${KVBASEDIR}/KitValidationPyJTPatches
                    if [ -s ${SWRELPATH}/cmtsite/asetup.sh -a $MAINRELVER -ge 160000 ] ; then
                        msgOut INFO "Setting up the main release runtime: ${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS} runtime"
                        eval ${SETUPCMD}${ASETUP_DBOPT}${PRJNAME} ${RELEASE} ${PRJOPT} ${ARUNTIME_TAGS} runtime
                    else
                        msgOut INFO "Setting up the main release runtime: ${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS},runtime"
                        eval ${SETUPCMD}${PRJNAME},${RELEASE},${PRJOPT}${RUNTIME_TAGS},runtime
                    fi
                    if [ -d $PWD/AtlasProduction/*/AtlasProductionRunTime/cmt ] ; then
                        EPREL="`find $PWD/AtlasProduction -maxdepth 1 -exec basename {} \; | tail -n 1`"
                        msgOut INFO "Setting up the embedded patch ${EPREL} runtime environment"
                        unset CMTPATH
                        cd $PWD/AtlasProduction/$EPREL/AtlasProductionRunTime/cmt
                        if [ -s setup.sh ] ; then
                            source setup.sh
                        else
                            msgOut WARNING "No setup found for the embedded patch! Skipping"
                        fi
                        cd -
                    fi
                fi
            fi
            if [ $validrc -eq 0 ] ; then
                # Start the test threads
                for kvthr in `seq 1 $TESTTHR`; do
                    TTDIR="$TESTDIR/KV.thr.$kvthr"
                    msgOut INFO "Creating dir $TTDIR"
                    mkdir -p $TTDIR; cd $TTDIR
                    \find $TESTDIR/ -maxdepth 1 -type d -name "KitValidation" -exec cp -a {} . \;
                    \find $TESTDIR/ -maxdepth 1 -type d -name "JobTransforms" -exec cp -a {} . \;
                    \find $TESTDIR/ -maxdepth 1 -type d -name "Atlas*" -exec ln -s {} . \;
                    KVHOME=`\find $PWD/KitValidation/ -type d -name share`
                    # Global test disable
                    [ "$KVDISABLE" != "" ] && KVDISABLE_OPTS=" --disable $KVDISABLE"
                    # Per-release test disable
                    KVDISREL="KVDISABLE_`echo $RELEASE | sed 's/\./_/g'`"
                    KVDISRELVAL="`eval echo \\$$KVDISREL`"
                    [ "$KVDISRELVAL" != "" ] && KVDISABLE_OPTS=" --disable $KVDISRELVAL"
                    # Switch off the compilation suite if the site type is not production
                    if [ -n "$SITETYPE" -a "$SITETYPE" != "analysis" ] ; then
                        [ -z "$KVD" ] && KVD="compilation" || KVD="${KVD},compilation"
                    fi
                    # Other disables
                    if [ "$KVD" != "" ] ; then
                        if [ "$KVDISABLE_OPTS" != "" ] ; then
                            KVDISABLE_OPTS="$KVDISABLE_OPTS,$KVD"
                        else
                            KVDISABLE_OPTS=" --disable $KVD"
                        fi
                    fi
                    KVVER="`${KVHOME}/KitValidation -V | grep version | awk '{print $4'} | awk -F. '{printf "%d",$1; for(i=2;i<=NF;i++) printf "%03d", $i;}'`"
                    if [ $KVVER -ge 1009015 -a "$REQPRJNAME" != "" ] ; then
                        # This switch is supported only since release 1.9.15 of KV
                        KVADDSEARCH=" --search $REQPRJNAME"
                    else
                        [ "$REQPRJNAME" != "" ] && msgOut WARNING "Ignoring KV release base search for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009016 -a "$KVPOSTTAG" != "" ] ; then
                        # This switch is supported only since release 1.9.16 of KV
                        KVPOSTTAG_OPTS=" --kvpost-tag ${KVPOSTTAG}"
                    else
                        [ "$KVPOSTTAG" != "" ] && msgOut WARNING "Ignoring KV user tags for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009017 -a "$KVCONFURL" != "" ] ; then
                        # This switch is supported only since release 1.9.17 of KV
                        KVCONFURL_OPTS=" --test-config \"${KVCONFURL}\""
                    else
                        [ "$KVCONFURL" != "" ] && msgOut WARNING "Ignoring KV custom configuration XML for KV-$KVVER"
                    fi
                    if [ $KVVER -ge 1009016 ] ; then
                        # This switch is supported only since release 1.9.16 of KV
                        # Per-release test enable
                        KVENAREL="KVENABLE_`echo $RELEASE | sed 's/\./_/g'`"
                        KVENARELVAL="`eval echo \\$$KVENAREL`"
                        [ "$KVENARELVAL" != "" ] && KVENABLE_OPTS=" --enable $KVENARELVAL"
                        # Other test enable
                        [ "$KVE" != "" ] && KVENABLE_OPTS=" --enable ${KVE}"
                    else
                        [ "$KVE" != "" ] && msgOut WARNING "Test enabling not supported in KV-$KVVER"
                    fi
                    [ "$KVNOAUTO" == "y" ] && KVNOAUTO_OPTS=" --no-auto"
                    msgOut INFO "Starting KV (thread #${kvthr}/${TESTTHR})..."
                    msgOut INFO "${KVHOME}/KitValidation -r ${RELEASE}${KVRELTYPE} -p ${SWRELPATH} -gkvn --bw -t ${PWD} ${KVBUILD_OPTS}${KVDISABLE_OPTS}${KVADDSEARCH}${KVPOSTTAG_OPTS}${KVCONFURL_OPTS}${KVENABLE_OPTS}${KVNOAUTO_OPTS}"
                    if [ "$DEBUG" == "yes" ] ; then
                        msgOut DEBUG "PATH=${PATH}"
                        msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
                        msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
                    fi

                    # Force running with a single process, even when ATHENA_PROC_NUMBER is set
                    [ -n "$ATHENA_PROC_NUMBER" ] && unset ATHENA_PROC_NUMBER

                    (${KVHOME}/KitValidation -r ${RELEASE}${KVRELTYPE} -p ${SWRELPATH} -gkvn --bw \
                     -t ${PWD} ${KVBUILD_OPTS}${KVDISABLE_OPTS}${KVADDSEARCH}${KVPOSTTAG_OPTS}${KVCONFURL_OPTS}${KVENABLE_OPTS}${KVNOAUTO_OPTS}; \
                     echo $? > ${TTDIR}.rc) &
                done
                # Wait for the threads to finish
                msgOut INFO "Waiting for ${TESTTHR} thread(s) to finish"
                wait
                # Calculate the global return code
                for kvthr in `seq 1 $TESTTHR`; do
                    TTDIR="$TESTDIR/KV.thr.$kvthr"
                    let validrc=$validrc+`cat ${TTDIR}.rc`
                done
            fi
        fi
    fi

    # Print out the test result
    if [ $validrc -ne 0 ] ; then
        msgOut ERROR "Test FAILED [rc=$validrc]"
    else
        msgOut INFO "Test OK [rc=$validrc]"
    fi

    # Clean up
    cd ${TOPDIR}
    if [ "$KVKEEP" != "y" ] ; then
        msgOut INFO "Removing test data"
        rm -fr "$TESTDIR"
    else
        msgOut INFO "Keeping test data in $TESTDIR"
    fi

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # End of the function
    return $validrc
}


findRelease() {
    RELDEFAULTLOC="${1}"
    DIRFOUND="`find ${RELDEFAULTLOC} -name "AtlasRelease" -o -name "${PRJNAME}Release" -type d 2>/dev/null | grep ".*[(dist),(${PRJNAME})]/${RELEASE}/" | tail -n 1`"
    if [ "$DIRFOUND" == "" ] ; then
        STARTDIR="`echo ${RELDEFAULTLOC} | xargs dirname | xargs dirname`"
        #[ "$VO_ATLAS_SW_DIR" != "" ] && STARTDIR=$VO_ATLAS_SW_DIR
        echo "The default directory $RELDEFAULTLOC does not contain release $RELEASE. Searching release $RELEASE performing a FULL DISK SCAN starting from $STARTDIR" > /dev/stderr
        DIRFOUND="`find $STARTDIR -name "AtlasRelease" -o -name "${PRJNAME}Release" -type d 2>/dev/null | grep ".*[(dist),(${PRJNAME})]/${RELEASE}/" | tail -n 1`"
    fi
    if [ "$DIRFOUND" != "" ] ; then
        echo "Release found in $DIRFOUND" > /dev/stderr
        DIRFOUND="`dirname $DIRFOUND | xargs dirname | xargs dirname`"
        echo "Using installation dir $DIRFOUND" > /dev/stderr
    fi
    echo $DIRFOUND
}


remove() {
    let removerc=0
    msgOut INFO "Removal of ${PRJNAME} ${RELEASE} started at `date`"

    # Main release path
    [ -n "${MAINRELPATH}" ] && RELPATH="${MAINRELPATH}" || RELPATH="${SWLOC}"

    # Main release version
    MAINRELVER="`echo $RELEASE | awk -F "." '{for (i=1;i<=3;i++) ver=sprintf("%s%02d",ver,$i)}END{print int(ver)}'`"

    # Paths
    [ -z "${SWLOC}" -a -n "${RELLOC}" ] && SWLOC="${RELLOC}"
    [ -z "${RELLOC}" -a -n "${SWLOC}" ] && RELLOC="${SWLOC}"

    if [ "$PRJTYPE" == "poolcond" ] ; then
        cleanup
        removerc=$?
    elif [ "$PRJTYPE" == "tdaq" ] ; then
        cd ${RELLOC}
        if [ -d "$PRJNAME" ] ; then
            msgOut INFO "Removing all ${ATLASRELEASE}* packages from $PWD"
            rpm -qa --dbpath $PWD/.rpmdb | grep ^${ATLASRELEASE} | xargs -r rpm --dbpath $PWD/.rpmdb -e --nodeps
            removerc=$?
            [ $removerc -ne 0 ] && msgOut INFO "Error removing RPM packages"
        else
            msgOut INFO "No directory $PRJNAME found"
        fi
    else
        # Setup the release and check the physical install path
        if [ -s "${RELPATH}/cmtsite/asetup.sh" -a $MAINRELVER -ge 160000 ] ; then
            SETUPFILE="${RELPATH}/cmtsite/asetup.sh"
        elif [ -s "${RELPATH}/cmtsite/setup.sh" ] ; then
            SETUPFILE="${RELPATH}/cmtsite/setup.sh"
        else
            SETUPFILE="${RELPATH}/setup.sh"
        fi
        if [ -s ${SETUPFILE} ] ; then
            if [ "${SWLOC}" != "${RELLOC}" ] ; then
                msgOut INFO "Setting up ${PRJNAME} ${RELEASE} from ${SETUPFILE}"
                if [ "`basename ${SETUPFILE}`" == "asetup.sh" ] ; then
                    SITEROOT="`(source ${SETUPFILE} ${PRJNAME} ${RELEASE} 2>&1 > /dev/null;[ $? -eq 0 ] && echo ${SITEROOT})`"
                else
                    SITEROOT="`(source ${SETUPFILE} -tag=${PRJNAME},${RELEASE} 2>&1 > /dev/null;[ $? -eq 0 ] && echo ${SITEROOT})`"
                fi
                if [ "$PRJTYPE" == "ext" ] ; then
                    SITEROOT="`(source ${SETUPFILE} 2>&1 > /dev/null;env | grep ${RELLOC} 2>&1 > /dev/null;[ $? -eq 0 ] && echo ${RELLOC} || echo none)`"
                fi
                if [ "$SITEROOT" != "" ] ; then
                    msgOut INFO "SITEROOT is ${SITEROOT}"
                    if [ "${RELLOC}" != "${SITEROOT}" -a "${SWLOC}" != "${SITEROOT}" ] ; then
                        if [ "$PRJTYPE" != "ext" ] ; then
                            msgOut INFO "The logical installation dir point to a different version of ${PRJNAME}. I will not delete ${SWLOC}."
                            SWLOC="none"
                        else
                            BASEDIR="`dirname ${SWLOC}`"
                            NUMDIRS="`\ls -d ${BASEDIR}/* | grep -v -E "${SWLOC}|${RELLOC}" | wc -l`"
                            if [ ${NUMDIRS} -gt 0 ] ; then
                                msgOut INFO "The logical installation dir point to a different version of ${PRJNAME}. I will not delete ${SWLOC}."
                                SWLOC="none"
                            fi
                        fi
                    fi
                else
                    msgOut INFO "No SITEROOT defined"
                fi
            fi
        else
            msgOut INFO "No release setup found (${RELPATH}/setup.sh, ${RELPATH}/cmtsite/setup.sh or ${RELPATH}/cmtsite/asetup.sh)"
        fi

        # Uninstall the releases
        for RELLOCFOUND in `\ls -d ${RELLOC} ${RELLOC}.r* 2>/dev/null` ; do
            LOCKFILE=${RELLOCFOUND}/atlas-install.lock
            if [ "$PRJTYPE" != "ext" ] ; then
                # Detect the physical installation area
                RELLOCFOUND="`getRWpath ${RELLOCFOUND}`"
                msgOut INFO "Trying with release $RELEASE in $RELLOCFOUND"

                # Check if any patch is installed
                if [ "$RELLOCFOUND" != "" -a "$PRJTYPE" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "${PRJTYPE}" != "eventview" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" ] ; then
                    msgOut INFO "Detecting patches for $RELEASE"
                    cd "${RELLOC}"
                    PATCHRELARCH="`echo $ARCH | sed 's/^_//g'`"
                    #PATCHPATTERN="Atlas.*_`echo $RELEASE | sed 's#\.#_#g'`_[[:digit:]+].*"
                    #INSTALLED_PATCHES="`pacman -lc -d none | grep "$PATCHPATTERN" | cut -d "_" -f 2-5 | sed 's#_#\.#g' | sort | uniq`"
                    PATCHPATTERN=".*_`echo $RELEASE | sed 's#\.#_#g'`_[[:digit:]+]_${PATCHRELARCH}.*"
                    INSTALLED_PATCHES="`pacman -lc -d none | grep "$PATCHPATTERN" | awk '{print $2}' | sort | uniq | tr '\n' '.'`"
                    if [ "$INSTALLED_PATCHES" != "" ] ; then
                        msgOut ERROR "The following patches to ${RELEASE} are installed"
                        msgOut ERROR "`echo ${INSTALLED_PATCHES} | sed 's# #,#g'`"
                        msgOut ERROR "Please remove all the patches before removing release $RELEASE"
                        return 150
                    else
                        msgOut INFO "No installed patches found for release $RELEASE"
                    fi
                fi
            fi

            # Wait for previous installation process completion
            if [ -f ${LOCKFILE} ] ; then
                msgOut WARNING "Another installation process is currently active. Now waiting..."
                waittime=0
                while `test -f ${LOCKFILE}`; do
                    sleep 1s
                    let waittime=$waittime+1
                    if [ $waittime -gt 3600 ] ; then
                        msgOut WARNING "Timeout [3600 s]"
                        msgOut WARNING "Removing stale installation lock"
                        rm -f ${LOCKFILE}
                    fi
                done
            fi
            if [ -d `dirname ${LOCKFILE}` ] ; then
                msgOut INFO "Locking the installation area"
                echo "$RELEASE installation lock" > ${LOCKFILE}
                case `whoami` in
                    usatlas*) msgOut INFO "This is an OSG site with static accounts. No further action required"
                        ;;
                    *[0-9])
                        msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
                        chmod -R g+rw ${LOCKFILE} 2>/dev/null
                        [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
                        ;;
                esac
            else
                msgOut ERROR "Cannot lock the installation area because the directory does not exists."
            fi

            # Remove the physical installation
            if [ -d ${RELLOCFOUND} ] ; then
                RELLOCBEFORE="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
                [ "$RELLOCBEFORE" == "" ] && RELLOCBEFORE=0
                if [ $RELLOCBEFORE -lt $MININSTALLSIZE ] ; then
                    msgOut INFO "Physical installation area size is ${RELLOCBEFORE} kB. Removing the directory."
                    rm -fr ${RELLOCFOUND}
                    let removerc=$removerc+$?
                else
                    cd "${RELLOCFOUND}"
                    if [ "$PACKOPT" == "all" ] ; then
                        msgOut INFO "Removing gcc from $PWD"
                        pacman -remove ${RELEASE}/${GCC}
                    fi
                    # Check for the latest DBRelease
                    LATEST_DBREL_INFO="`ls DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1`"
                    LATEST_DBREL_VER="`echo $LATEST_DBREL_INFO | awk '{print $2}'`"
                    if [ "$DBREL" != "" -a -d "DBRelease/$DBREL" -a "$DBREL" != "$LATEST_DBREL_VER" ] ; then
                        msgOut INFO "Removing DBRelease $DBREL from $PWD"
                        pacman -remove ${DBRELPKG}
                        if [ $? -ne 0 ] ; then
                            msgOut WARNING "Trying to remove pacman lock"
                            pacman -clear-lock
                            if [ -f "o..pacman..o/lock" ] ; then
                                msgOut WARNING "Force lock removal"
                                rm -f o..pacman..o/lock
                            fi
                            pacman -remove ${DBRELPKG}
                        fi
                        let removerc=$removerc+$?
                        # Re-check for the latest DBRelease
                        LATEST_DBREL_INFO="`ls DBRelease | grep "[0-9]*\.[0-9]*\.[0-9]*" | awk -F '.' '{for (i=1;i<=NF;i++) printf "%03d", $i; printf " %s\n", $0;}' | sort | tail -n 1`"
                        LATEST_DBREL_VER="`echo $LATEST_DBREL_INFO | awk '{print $2}'`"
                        if [ ! -d "DBRelease/current" -a -z "$LATEST_DBREL_VER" ] ; then
                            msgOut INFO "Linking DBRelease $LATEST_DBREL_VER as current"
                            (
                                cd DBRelease
                                if [ $? -eq 0 ] ; then
                                    rm -f current
                                    ln -s $LATEST_DBREL_VER current
                                    cd ..
                                fi
                            )
                        fi
                        msgOut INFO "Current DBRelease: `ls -l DBRelease/current 2>/dev/null`"
                        [ $removerc -ne 0 ] && msgOut WARNING "Error during DBRelease removal"
                    fi
                    msgOut INFO "Removing physical installation of ${ATLASRELEASE} from $PWD"
                    pacman -remove ${ATLASRELEASE}
                    if [ $? -ne 0 ] ; then
                        msgOut WARNING "Trying to remove pacman lock"
                        pacman -clear-lock
                        if [ -f "o..pacman..o/lock" ] ; then
                            msgOut WARNING "Force lock removal"
                            rm -f o..pacman..o/lock
                        fi
                        pacman -remove ${ATLASRELEASE}
                    fi
                    rmtmprc=$?
                    if [ $rmtmprc -ne 0 ] ; then
                        ATLREL="`echo ${ATLASRELEASE} | sed 's/^AtlasOffline/AtlasProduction/'`"
                        if [ -n "$ATLREL" -a "$ATLREL" != "$ATLASRELEASE" ] ; then
                            msgOut WARNING "Cannot remove ${ATLASRELEASE}, trying with ${ATLREL}"
                            pacman -remove ${ATLREL}
                            rmtmprc=$?
                        fi
                    fi
                    let removerc=$removerc+$rmtmprc
                    [ $removerc -ne 0 ] && msgOut ERROR "Error while removing ${ATLASRELEASE}"
                    if [ $removerc -eq 0 -a "$EXTRAPKG" != "" ] ; then
                        msgOut INFO "Removing physical installation of ${EXTRAPKG} from $PWD"
                        pacman -remove ${EXTRAPKG}
                        if [ $? -ne 0 ] ; then
                            msgOut WARNING "Cannot remove ${EXTRAPKG}"
                            msgOut ERROR "`pacman -last`"
                        fi
                    fi
                    if [ "$RESTOREBCK" == "yes" ] ; then
                        for ATLASLOGINREQ in `\find AtlasLogin -name "requirements"`; do
                            if [ -f ${ATLASLOGINREQ}.orig ] ; then
                                msgOut INFO "Restoring ${ATLASLOGINREQ} from ${ATLASLOGINREQ}.orig"
                                cp -f ${ATLASLOGINREQ}.orig ${ATLASLOGINREQ}
                                msgOut INFO "`ls -l ${ATLASLOGINREQ}`"
                            fi
                        done
                    fi
                    if [ $removerc -ne 0 ] ; then
                        msgOut ERROR "`pacman -last`"
                    else
                        pacman -clear-snapshots

                        # Cleaning up the directories
                        [ -d dist/${RELEASE} ] && rm -fr dist/${RELEASE}
                        cd "${TOPDIR}"
                        RELLOCSIZE="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
                        [ "$RELLOCSIZE" == "" ] && RELLOCSIZE=-1
                        if [ ${RELLOCSIZE} -lt $MININSTALLSIZE ] ; then
                            if [ ${RELLOCSIZE} -lt 0 ] ; then
                                msgOut INFO "Physical installation area does not exists anymore."
                            else
                                msgOut INFO "Physical installation area size is ${RELLOCSIZE} kB. Removing the directory."
                                # Check if we're running in AFS and correct the installation path and removal method, if needed
                                if [ "`echo $RELLOCFOUND | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
                                    # Check if we are already in the rw path
                                    if [ "`echo $RELLOCFOUND | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
                                        AFSRLOC="`echo $RELLOCFOUND | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
                                        msgOut INFO "Removing data from volume $AFSRLOC"
                                        AFSREMOVE="`which afs_remove 2>/dev/null`"
                                        if [ "$AFSREMOVE" != "" ] ; then
                                            msgOut INFO "Destroying the volume using $AFSREMOVE"
                                            $AFSREMOVE $AFSRLOC
                                            let removerc=$removerc+$?
                                        else
                                            # Removing the directory contents
                                            msgOut INFO "No afs_remove found. Removing the contents of $RELLOCFOUND"
                                            rm -fr $RELLOCFOUND/*
                                            let removerc=$removerc+$?
                                            # Removing the directory itself, if this fails it's not a fatal error
                                            rmdir $RELLOCFOUND
                                            [ $? -ne 0 ] && msgOut WARNING "Cannot remove the directory $RELLOCFOUND"
                                        fi
                                    fi
                                else
                                    # Non-AFS filesystems
                                    rm -fr ${RELLOCFOUND}
                                    let removerc=$removerc+$?
                                fi
                            fi
                        else
                            msgOut INFO "Physical installation area size is ${RELLOCSIZE} kB. The directory is not empty."
                        fi 
                    fi
                fi
                RELLOCAFTER="`du -sk ${RELLOCFOUND} 2>/dev/null | awk '{print $1}'`"
                [ "$RELLOCAFTER" == "" ] && RELLOCAFTER=0
                msgOut INFO "Disk space saved: `echo $((${RELLOCBEFORE}-${RELLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
            else
                msgOut INFO "Physical installation area ($RELLOCFOUND) does not exists and no candidates have been found."
            fi
        done

        # Remove the logical installation, unless we're processing patches or we do not have it
        cd "${TOPDIR}"
        if [ "$PRJTYPE" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "${PRJTYPE}" != "eventview" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" -a "${SWLOC}" != "none" -a "$SWLOC" != "$RELLOC" ] ; then
            if [ -d ${SWLOC} ] ; then
                SWLOC="`getRWpath ${SWLOC}`"
                msgOut INFO "Removing logical installation from ${SWLOC}"
                SWLOCBEFORE="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
                [ "$SWLOCBEFORE" == "" ] && SWLOCBEFORE=0
                rm -fr "${SWLOC}"
                SWLOCAFTER="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
                [ "$SWLOCAFTER" == "" ] && SWLOCAFTER=0
                msgOut INFO "Disk space saved: `echo $((${SWLOCBEFORE}-${SWLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
            else
                msgOut INFO "Logical installation area ($SWLOC) does not exists."
            fi
            # Remove the logical area link
            if [ -n "$LOGLINK" ] ; then
                if [ -L "$LOGLINK" ] ; then
                    msgOut INFO "Removing link ${LOGLINK}"
                    rm -f ${LOGLINK}
                else
                    msgOut INFO "${LOGLINK} not found"
                fi
            fi
            # Remove the physical area link
            if [ -n "$PHYSLINK" ] ; then
                if [ -L "$PHYSLINK" ] ; then
                    msgOut INFO "Removing link ${PHYSLINK}"
                    rm -f ${PHYSLINK}
                else
                    msgOut INFO "${PHYSLINK} not found"
                fi
            fi
        fi

        # Clean up the site configuration
        [ "$PRJTYPE" == "ext" -a "$PRJNAME" == "gcc" ] && unsetCompiler

        # Clean the local config
        [ "$PRJTYPE" == "poolcond" -a "$GRIDNAME" != "NORDUGRID" ] && unsetLocalConfig

        # List the software area contents
        SWLOCPATH="`dirname ${SWLOC}`" 
        RELLOCPATH="`dirname ${RELLOC}`" 
        if [ "${PRJTYPE}" != "patch" -a "${PRJTYPE}" != "p1patch" -a "$PRJTYPE" != "t0patch" -a "${PRJTYPE}" != "eventview" -a "$PRJTYPE" != "analysis" -a "$PRJTYPE" != "tdaq" -a "$SWLOC" != "none" -a "$SWLOC" != "$RELLOC" ] ; then
            msgOut INFO "Showing contents of the logical installation path (${SWLOCPATH})"
            msgOut INFO "`\ls ${SWLOCPATH}`"
        fi
        msgOut INFO "Showing contents of the physical installation parent path (${RELLOCPATH})"
        msgOut INFO "`\ls ${RELLOCPATH}`"
        msgOut INFO "Unlocking the installation area"
        rm -f ${LOCKFILE}
    fi

    return $removerc
}

prepareTagging() {
    # Search and define the tagging utility
    if [ "$TAGMODE" == "file" ] ; then
        TAG_UTILITY="OSGTags"
        msgOut INFO "Using embedded $TAG_UTILITY"
    else
        if [ "$GRIDNAME" == "OSG" ] ; then
            TAG_UTILITY="OSGTags"
            msgOut INFO "Using embedded $TAG_UTILITY for $GRIDNAME Grid"
        else
            if [ "$GRIDNAME" != "EGEE" ] ; then
                msgOut INFO "Unknown Grid specified, assuming we are on EGEE"
                GRIDNAME="EGEE"
            fi
            TAG_UTILITY="`which lcg-tags 2> /dev/null`"
            if [ "$TAG_UTILITY" == "" ] ; then
                msgOut ERROR "Tagging utility (lcg-tags) not present."
                return 60
            else
                msgOut INFO "Using $TAG_UTILITY for $GRIDNAME Grid"
            fi
        fi
    fi
    return 0
}

addTag() {
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    #/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVLAST
    /usr/bin/env | grep '=' | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Prepare for tagging
    prepareTagging
    let addtagrc=$?

    # Manage the tags
    if [ "$TAGMODE" != "file" ] ; then
        if [ "$TAGHOST" == "" ] ; then
            msgOut ERROR "No host to manage tags"
            let addtagrc=$addtagrc+1
        fi
        if [ "$TAGVO" == "" ] ; then
            msgOut ERROR "No VO to manage tags"
            let addtagrc=$addtagrc+1
        fi
    fi
    if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
        [ "$TAGFILE" != "" ] && TF_OPT="--file $TAGFILE"
    fi
    if [ $addtagrc -eq 0 ] ; then
        if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
            msgOut INFO "Listing current subcluster tags for $TAGSCNAME"
            msgOut INFO "`$TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list $TF_OPT`"
        else
            msgOut INFO "Listing current cluster tags for $TAGHOST"
            msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT`"
        fi
        msgOut INFO "Adding tags $TAGNAME"
        if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
            msgOut INFO "Tagging cluster $TAGHOST [OSG/file]"
            msgOut INFO "$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags $TAGNAME --project $PRJNAME --location $RELLOC --debug $TF_OPT"
            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags $TAGNAME --project $PRJNAME --location $RELLOC --debug $TF_OPT
        else
            if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                msgOut INFO "Tagging subcluster $TAGSCNAME"
                $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --add --tags $TAGNAME
            else
                msgOut INFO "Tagging cluster $TAGHOST"
                $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags $TAGNAME
            fi
        fi
        let addtagrc=$addtagrc+$?

        # Extra tag
        if [ $addtagrc -eq 0 ] ; then
            if [ "$EXTRATAG" != "" ] ; then
                TAGDEL="`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list | grep ${EXTRATAG}$ | tail -n 1`"
                if [ "$TAGDEL" != "" ] ; then
                    msgOut INFO "Removing tag $TAGDEL"
                    if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                        $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --remove --tags $TAGDEL
                    else
                        $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags $TAGDEL
                    fi
                    let addtagrc=$addtagrc+$?
                fi
                if [ $addtagrc -eq 0 ] ; then
                    msgOut INFO "Adding tag ${TAGNAME}-${EXTRATAG}"
                    if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
                        $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags ${TAGNAME}-${EXTRATAG} --project $PRJNAME --location $RELLOC $TF_OPT
                    else
                        if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                            $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --add --tags ${TAGNAME}-${EXTRATAG}
                        else
                            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --add --tags ${TAGNAME}-${EXTRATAG}
                        fi
                    fi
                    let addtagrc=$addtagrc+$?
                else
                    msgOut ERROR "Cannot remove tag $TAGDEL"
                fi
            fi
        fi
        if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
            msgOut INFO "Listing current tags for $TAGHOST [OSG/file]"
            msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT`"
        else
            if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                msgOut INFO "Listing tags for subcluster $TAGSCNAME"
                msgOut INFO "`$TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list $TF_OPT`"
                $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list  $TF_OPT | grep -q ${TAGNAME}
            else
                msgOut INFO "Listing tags for host $TAGHOST"
                msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT`"
                $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT | grep -q ${TAGNAME}
            fi
        fi
        if [ $addtagrc -eq 0 -a $? -ne 0 ] ; then
            msgOut ERROR "The tagging utility reports no error but the tag was not added"
            let addtagrc=$addtagrc+1
        fi
        if [ "$DUMPTAGS" != "" ] ; then
            # Check if we are running in AFS
            if [ "`echo $DUMPTAGS | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
                # Check if we are already in the rw path 
                if [ "`echo $DUMPTAGS | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
                    DUMPTAGS="`echo $DUMPTAGS | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
                fi
            fi
            if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                DUMPTAGS="${DUMPTAGS}-${TAGSCNAME}"
                DUMPTAGSDIR="`dirname ${DUMPTAGS}`"
                if [ "`getFSType $DUMPTAGSDIR`" == "cvmfs" ] ; then
                    msgOut INFO "No tag dump for CVMFS"
                else
                    msgOut INFO "Dumping subcluster tags into $DUMPTAGS"
                    $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list $TF_OPT > $DUMPTAGS
                fi
            else
                DUMPTAGSDIR="`dirname ${DUMPTAGS}`"
                if [ "`getFSType $DUMPTAGSDIR`" == "cvmfs" ] ; then
                    msgOut INFO "No tag dump for CVMFS"
                else
                    msgOut INFO "Dumping cluster tags into $DUMPTAGS"
                    $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT > $DUMPTAGS
                fi
            fi
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Cannot dump tags to $DUMPTAGS"
                if [ "$ACTION" == "install" -o "$ACTION" == "validate" ] ; then
                    let addtagrc=$addtagrc+1
                else
                    msgOut INFO "Ignoring error on tag dump for action [${ACTION}]"
                fi
            fi
        else
            msgOut INFO "No tag dump"
        fi
    fi

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # Return from this fuction
    return $addtagrc
}


removeTag() {
    # Reset the environment
    ENVLAST="/tmp/sw-mgr-envlast.tmp.$$"
    #/usr/bin/printenv | grep -v '^_=' | sed -e "s/\([^=]\)=/\1='/" -e "s/$/'/g" > $ENVLAST
    /usr/bin/env | grep '=' | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVLAST
    if [ -s $ENVSTART ] ; then
        echo "ENVLAST=\"$ENVLAST\"" >> $ENVSTART
        msgOut INFO "Resetting the environment from $ENVSTART"
        source $ENVSTART
    fi

    # Prepare for tagging
    prepareTagging
    let removetagrc=$?

    # Manage the tags
    if [ "$TAGMODE" != "file" ] ; then
        if [ "$TAGHOST" == "" ] ; then
            msgOut ERROR "No host to manage tags"
            let removetagrc=$removetagrc+1
        fi
        if [ "$TAGVO" == "" ] ; then
            msgOut ERROR "No VO to manage tags"
            let removetagrc=$removetagrc+1
        fi
    fi
    if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
        [ "$TAGFILE" != "" ] && TF_OPT="--file $TAGFILE"
    fi
    if [ $removetagrc -eq 0 ] ; then
        msgOut INFO "Removing tags $TAGNAME"
        if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
            $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags ${TAGNAME} --project $PRJNAME --location $RELLOC $TF_OPT
        else
            if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                msgOut INFO "Removing tags from subcluster $TAGSCNAME"
                $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --remove --tags $TAGNAME
            else
                msgOut INFO "Removing tags from cluster $TAGHOST"
                $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags $TAGNAME
            fi
        fi
        let removetagrc=$removetagrc+$?

        # Extra tag
        if [ "$EXTRATAG" != "" ] ; then
            msgOut INFO "Removing tag ${TAGNAME}-${EXTRATAG}"
            if [ "$GRIDNAME" == "OSG" -o "$TAGMODE" == "file" ] ; then
                $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags ${TAGNAME}-${EXTRATAG} --project $PRJNAME --location $RELLOC $TF_OPT
            else
                if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                    $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --remove --tags ${TAGNAME}-${EXTRATAG}
                else
                    $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --remove --tags ${TAGNAME}-${EXTRATAG}
                fi
            fi
            let removetagrc=$removetagrc+$?
        fi
        if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
            msgOut INFO "Listing current subcluster tags for ${TAGHOST}/${TAGSCNAME}"
            msgOut INFO "`$TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list $TF_OPT`"
        else
            msgOut INFO "Listing current cluster tags for $TAGHOST"
            msgOut INFO "`$TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT`"
        fi
        if [ "$DUMPTAGS" != "" ] ; then
            # Check if we are running in AFS
            if [ "`echo $DUMPTAGS | sed 's#^/\(afs\).*#\1#g'`" == "afs" ] ; then
                # Check if we are already in the rw path 
                if [ "`echo $DUMPTAGS | sed 's#^/afs/\(.\).*#\1#g'`" != "." ] ; then
                    DUMPTAGS="`echo $DUMPTAGS | sed 's#^/afs/\(.*\)#/afs/.\1#g'`"
                fi
            fi
            if [ -n "$TAGSCNAME" -a "$TAGSCNAME" != "$TAGHOST" ] ; then
                DUMPTAGS="${DUMPTAGS}-${TAGSCNAME}"
                msgOut INFO "Dumping subcluster tags into $DUMPTAGS"
                $TAG_UTILITY --sc $TAGSCNAME --vo $TAGVO --list $TF_OPT > $DUMPTAGS
            else
                msgOut INFO "Dumping cluster tags into $DUMPTAGS"
                $TAG_UTILITY --ce $TAGHOST --vo $TAGVO --list $TF_OPT > $DUMPTAGS
            fi
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Cannot dump tags to $DUMPTAGS"
                if [ "$ACTION" == "remove" -o "$ACTION" == "cleanup" ] ; then
                    let removetagrc=$removetagrc+1
                else
                    msgOut INFO "Ignoring error on tag dump for action [${ACTION}]"
                fi
            fi
        fi
    fi

    # Reset the environment
    if [ -s $ENVLAST ] ; then
        msgOut INFO "Reverting to the environment from $ENVLAST"
        source $ENVLAST
        rm -f $ENVLAST
    fi

    # Return from this fuction
    return $removetagrc
}


relocateRelease() {
    FROMPATH=${1}
    TOPATH=${2}
    SPATH=${3}
    [ "$SPATH" == "" ] && SPATH=$FROMPATH
    PFROMPATH="`dirname $FROMPATH`"
    PTOPATH="`dirname $TOPATH`"

    msgOut INFO "Relocating files in $SPATH from $FROMPATH to $TOPATH"
    \find $SPATH -type f -path "*/cmt*/*" -o -name "*cmtref" -o -name "*.sh" -o -name "*.csh" | \
    while read INFILE; do
        egrep "$PFROMPATH|$FROMPATH" "$INFILE" 2>&1 > /dev/null
        if [ $? -eq 0 ] ; then
            echo "Relocating file $INFILE"
            if [ "$PFROMPATH" != "/" -a "$PTOPATH" != "/" ] ; then
                sed -i -e "s#${FROMPATH}#${TOPATH}#g" -e "s#${PFROMPATH}#${PTOPATH}#g" "$INFILE"
            else
                sed -i "s#${FROMPATH}#${TOPATH}#g" "$INFILE"
            fi
        fi
    done

    msgOut INFO "Relocating links in $SPATH from $FROMPATH to $TOPATH"
    \find $SPATH -type l -lname "${FROMPATH}*" | \
    while read INLINK; do
        echo "Fixing link $INLINK"
        NEWLINK="`\ls -l "$INLINK" | awk -F " -> " '{print $2}' | sed "s#$FROMPATH#$TOPATH#g"`"
        echo ln -sf "$NEWLINK" "$INLINK"
        ln -sf "$NEWLINK" "$INLINK"
    done

    if [ -d "$SPATH/DBRelease" ] ; then
        msgOut INFO "Relocating DBRelease in $SPATH from $FROMPATH to $TOPATH"
        \find $SPATH/DBRelease -noleaf -type f -name "*.xml" | xargs -r sed -i "s#$FROMPATH#$TOPATH#g"
    fi
}


setDDMhelper() {
    # Check if dq2 and the python interface are available
    DDMHELPER="$INSTALLER_HOME/getFrontierEnv.py"
    if [ ! -s "$DDMHELPER" ] ; then
        msgOut ERROR "No getFrontierEnv.py found in $INSTALLER_HOME"
        return 1
    fi
    python -c "import dq2.info.TiersOfATLAS" &> /dev/null
    if [ $? -ne 0 ] ; then
        msgOut ERROR "DDM is not available or cannot import dq2.info.TiersOfATLAS"
        return 2
    fi
    msgOut INFO "Using DDM helper $DDMHELPER"
    return 0
}


genPoolcondPFC() {
    # Return code
    gprc=0

    # Check if dq2-ls and dq2-get are available
    DQ2LS="`which dq2-ls 2>/dev/null`"
    DQ2LSVER="`dq2-ls --version 2>/dev/null | sed 's/[^0-9]*\([0-9]*\)\.\([0-9]*\).*/\1.\2/' | awk -F'.' '{printf "%d%03d",$1,$2}'`"
    DQ2GET="`which dq2-get 2>/dev/null`"
    DQ2PFCGEN="`which dq2-PFC-gen 2> /dev/null`"
    if [ "$DQ2LS" == "" ] ; then
        msgOut ERROR "No dq2-ls found"
        return 1
    else
        msgOut INFO "Using $DQ2LS"
    fi
    if [ "$DQ2GET" == "" ] ; then
        msgOut ERROR "No dq2-get found"
        return 1
    fi
    [ "$DQ2LSVER" != "" ] && msgOut INFO "dq2-ls v$DQ2LSVER found"

    # Check if we are able to use LFC
    python -c "import lfc" &> /dev/null
    let gprc=$?
    if [ $gprc -ne 0 ] ; then
        MAXREL=$((${#RELSETUPLIST[@]}-1))
        if [ ${MAXREL} -ge 0 ] ; then
            for r in `seq $MAXREL -1 0`; do
                if [ -n "${RELPYTHON[$r]}" ] ; then
                    OLDPYTHON="`which python`"
                    OLDPATH="$PATH"
                    OLDPYTHONPATH="$PYTHONPATH"
                    OLDLIBRARYPATH="$LD_LIBRARY_PATH"
                    export PATH=${RELPYTHON[$r]}/bin:$PATH
                    export PYTHONPATH=${RELPYTHON[$r]}/bin:${RELPYTHON[$r]}/lib:$PYTHONPATH
                    export LD_LIBRARY_PATH=${RELPYTHON[$r]}/lib:$LD_LIBRARY_PATH
                    msgOut WARNING "Cannot import LFC bindings using $OLDPYTHON. Trying with `which python`"
                    python -c "import lfc" &> /dev/null
                    let gprc=$?
                    if [ $gprc -eq 0 ] ; then
                        msgOut INFO "LFC import successful using `which python`"
                        break
                    fi
                    export PATH=$OLDPATH
                    export PYTHONPATH=$OLDPYTHONPATH
                    export LD_LIBRARY_PATH=$OLDLIBRARYPATH
                else
                    msgOut WARNING "No python in release `echo ${RELLIST[$r]} | sed 's#.*/AtlasOffline/\([0-9\.]*\)/.*#\1#'`"
                fi
            done
        else
            msgOut ERROR "Cannot import LFC bindings using `which python` and no ATLAS sw release is found"
        fi
    fi
    if [ $gprc -ne 0 ] ; then
        msgOut ERROR "Cannot import LFC bindings"
        return $gprc
    fi

    # Set up the ddm helper
    [ -z "$DDMHELPER" ] && setDDMhelper

    # Override the dq2 configuration if a file dq2.cfg in present in the current working dir or in the installation top dir
    if [ -s $TOPDIR/dq2.cfg ] ; then
        DQ2OVERRIDE="$TOPDIR/dq2.cfg"
    elif [ -s $INSTALLER_HOME/dq2.cfg ] ; then
        DQ2OVERRIDE="$INSTALLER_HOME/dq2.cfg"
    else
        msgOut INFO "No DQ2 overrides found in $TOPDIR or $INSTALLER_HOME"
    fi
    if [ -n "$DQ2OVERRIDE" ] ; then
        msgOut INFO "Overriding the default DQ2 configuration with ~/.dq2/etc/dq2.cfg"
        mkdir -p ~/.dq2/etc
        cp $DQ2OVERRIDE ~/.dq2/etc
        msgOut INFO "DQ2URL: `grep '^url=' ~/.dq2/etc/dq2.cfg`"
        [ -f /var/tmp/.dq2${USER}/ToACache.py ] && rm -f /var/tmp/.dq2${USER}/ToACache.py
    fi

    # Generate a Poolcond PFC for the local site
    if [ "$PCPATTERN" != "" -o "$PCMODE" == "gen" ] ; then
        [ "$DDMSITE" == "" -a "$DQ2_LOCAL_SITE_ID" != "" ] && DDMSITE="`echo $DQ2_LOCAL_SITE_ID | sed 's/\(.*\)_\(.*\)/\1_HOTDISK/'`"
        if [ "$DDMSITE" != "" ] ; then
            PFCDIR="$PWD"
            PFCTMPDIR="/tmp/pfctmp.$$"
            [ ! -d $PFCTMPDIR ] && mkdir -p $PFCTMPDIR
            if [ -d $PFCTMPDIR ] ; then
                msgOut INFO "Proxy info:"
                msgOut INFO "`voms-proxy-info -all`"
                # Try to detect the se type from the DDM
                if [ -n "$DDMHELPER" ] ; then
                    if [ -f $DDMHELPER ] ; then
                        SETYPE="`python $DDMHELPER --setype $DDMSITE | tr a-z A-Z`"
                        SEREGEXP="`python $DDMHELPER --regexp $DDMSITE 2>/dev/null`"
                        msgOut INFO "Checking the storage type with DDM ($SETYPE)"
                    else
                        msgOut INFO "No DDM helper found"
                    fi
                fi
                [ -n "$SETYPE" ] && msgOut INFO "DDM declares $DDMSITE as $SETYPE" || msgOut INFO "No DDM SE info for $DDMSITE"
            
                if [ "$PCMODE" == "all" -o "$PCMODE" == "get" ] ; then
                    if [ -n "$PCTOPDIR" ] ; then
                        msgOut INFO "Local storage site detected. Storing the poolcond files in $PCTOPDIR"
                        [ ! -d $PCTOPDIR ] && mkdir -p $PCTOPDIR
                        if [ -d $PCTOPDIR ] ; then
                            SETYPE="FILE"
                            cd $PCTOPDIR
                            DQ2OPTS="-d -L ROAMING -s $DDMSITE"
                            [ "$DDMVERIFY" != "yes" ] && DQ2OPTS="-V $DQ2OPTS"
                            for d in $PCPATTERN; do
                                msgOut INFO "Getting dataset $d from $DDMSITE"
                                $DQ2GET $DQ2OPTS $d
                                let gprc=$gprc+$?
                                [ $gprc -ne 0 ] && msgOut ERROR "Failed to get dataset $d"
                            done
                        else
                            msgOut ERROR "Cannot create $PCTOPDIR"
                            let gprc=1
                        fi
                    elif [ -n "$SETYPE" ] ; then
                        msgOut INFO "$SETYPE site detected from DDM"
                    elif [ -n "$DPM_HOST" ] ; then
                        msgOut INFO "DPM site detected from DPM_HOST"
                    elif [ -n "$STORM_HOST" ] ; then
                        msgOut INFO "STORM site detected from STORM_HOST"
                    else
                        msgOut INFO "Generic SE site detected (fallback)"
                    fi

                    # Fix for plain poolcond file access
                    if [ $gprc -eq 0 ] ; then
                        if [ "$PFCCOPY" == "yes" ] ; then
                            MAXREL=$((${#RELSETUPLIST[@]}-1))
                            if [ ${MAXREL} -ge 0 ] ; then
                                # Run in a subshell
                                (
                                    dbrfcprc=0
                                    for r in `seq $MAXREL -1 0`; do
                                        msgOut INFO "Trying to setup the ATLAS sw release with ${RELSETUPLIST[$r]}"
                                        eval ${RELSETUPLIST[$r]}
                                        DBRPOOLCOND="`ls -d $SITEROOT/DBRelease/current/poolcond 2>/dev/null`"
                                        if [ -n "$DBRPOOLCOND" ] ; then
                                            msgOut INFO "Copying the PoolCat xml files from ${DBRPOOLCOND} to ${PFCDIR}"
                                            cp -f ${DBRPOOLCOND}/PoolCat*.xml ${PFCDIR}
                                            let dbrfcprc=$dbrfcprc+$?
                                            [ $dbrfcprc -ne 0 ] && msgOut ERROR "Cannot copy the PoolCat xml files"
                                            break
                                        fi
                                    done
                                    [ -z "$DBRPOOLCOND" ] && msgOut ERROR "Cannot find any suitable DBRelease to copy the PoolCat xml files"
                                    exit $dbrfcprc
                                )
                                let gprc=$gprc+$?
                            else
                                msgOut ERROR "No ATLAS release found, unable to get the DBRelease PFC files"
                            fi
                        else
                            DBRPFC="`\ls -d ${PFCDIR}/PoolCat*.xml 2>/dev/null`"
                            if [ -n "$DBRPFC" ] ; then
                                msgOut INFO "Removing the PoolCat xml files from ${PFCDIR}"
                                rm -f ${PFCDIR}/PoolCat*.xml
                                let gprc=$gprc+$?
                                [ $gprc -ne 0 ] && msgOut ERROR "Cannot remove the PoolCat xml files"
                            fi
                        fi
                    fi
                fi

                if [ "$PCMODE" == "all" -o "$PCMODE" == "gen" ] ; then
                    # Generate the PFC
                    cd $PFCTMPDIR
                    msgOut INFO "Generating temporary PFC in $PWD"
                    [ -n "$PCTOPDIR" ] && SETYPE="FILE"
                    if [ "$SETYPE" != "FILE" ] ; then
                        for d in $PCPATTERN; do
                            msgOut INFO "Generating PFC in site $DDMSITE for dataset $d"
                            if [ -n "$DQ2PFCGEN" ] ; then
                                # Use the new PFC gen tools from DQ2
                                $DQ2PFCGEN -L $DDMSITE $d
                            else
                                # Use the legacy PFC gen tools from DQ2
                                if [ -n "$SETYPE" ] ; then
                                    # DDM detection
                                    if [ "$SETYPE" == "DPM" ] ; then
                                        msgOut INFO "Using dq2 options -P -R [DPM]"
                                        $DQ2LS -P -R ".*/dpm/^rfio:/dpm/" -L $DDMSITE $d
                                    elif [ "$SETYPE" == "STORM" -o "$SETYPE" == "XROOTD" ] ; then
                                        if [ $DQ2LSVER -gt 1002 ] ; then
                                            # dq2-ls > 1.2 correctly handles STORM
                                            msgOut INFO "Using dq2 options -P -G [STORM]"
                                            $DQ2LS -P -G -L $DDMSITE $d
                                        else
                                            # dq2-ls <= 1.2 needs a regexp for STORM
                                            msgOut INFO "Using dq2 options -P -R [STORM]"
                                            $DQ2LS -P -R ".*://[A-Za-z0-9-._]*/^/" -L $DDMSITE $d
                                        fi
                                    elif [ "$SETYPE" == "DCACHE" -a -z "$SEREGEXP" ] ; then
                                        msgOut INFO "Using dq2 options -P -G [DCACHE NOREGEXP]"
                                        $DQ2LS -P -G -L $DDMSITE $d
                                    elif [ "$SETYPE" == "DCACHE" -a -n "$SEREGEXP" ] ; then
                                        msgOut INFO "Using dq2 options -P -G [DCACHE REGEXP]"
                                        $DQ2LS -P -G -L $DDMSITE $d
                                    else
                                        # Everything else
                                        msgOut INFO "Using dq2 options -P -G [GENERIC]"
                                        $DQ2LS -P -G -L $DDMSITE $d
                                    fi
                                    let gprc=$gprc+$?
                                else
                                    # Site detection
                                    if [ -n "$DPM_HOST" ] ; then
                                        msgOut INFO "Using dq2 options -P -R [DPM]"
                                        $DQ2LS -P -R ".*/dpm/^rfio:/dpm/" -L $DDMSITE $d
                                    elif [ -n "$STORM_HOST" ] ; then
                                        if [ $DQ2LSVER -gt 1002 ] ; then
                                            # dq2-ls > 1.2 correctly handles STORM
                                            msgOut INFO "Using dq2 options -P -G [STORM]"
                                            $DQ2LS -P -G -L $DDMSITE $d
                                        else
                                            # dq2-ls <= 1.2 needs a regexp for STORM
                                            msgOut INFO "Using dq2 options -P -R [STORM]"
                                            $DQ2LS -P -R ".*://[A-Za-z0-9-._]*/^/" -L $DDMSITE $d
                                        fi
                                    else
                                        msgOut INFO "Using dq2 options -P -G [GENERIC]"
                                        $DQ2LS -P -G -L $DDMSITE $d
                                    fi
                                    let gprc=$gprc+$?
                                fi
                            fi
                        done
                        if [ "$SETYPE" == "STORM" -a -s PoolFileCatalog.xml ] ; then
                            msgOut INFO "Fixing wrong PFC entries for STORM"
                            sed -i -e 's#/atlashotdisk\([^/]\)#/atlashotdisk/\1#g' PoolFileCatalog.xml
                        fi
                    else
                        # File-based repository
                        msgOut INFO "Generating T3-style PFC"
                        if [ "$PCTOPDIR" != "" ] ; then
                            if [ -n "$PCSCANDIR" ] ; then
                                # Scan the subdirs below $PCTOPDIR
                                PCTOPDIRLIST="`\ls -d $PCTOPDIR/*`"
                            else
                                PCTOPDIRLIST="$PCTOPDIR"
                            fi
                            for PCTGTDIR in $PCTOPDIRLIST; do
                                if [ -n "$DQ2PFCGEN" ] ; then
                                    # Use the new PFC gen tools from DQ2
                                    msgOut INFO "$DQ2PFCGEN -L ROAMING -T $PCTGTDIR"
                                    $DQ2PFCGEN -L ROAMING -T $PCTGTDIR
                                    let gprc=$gprc+$?
                                else
                                    # Use the legacy PFC gen tools from DQ2
                                    msgOut INFO "$DQ2LS -L ROAMING -T $PCTGTDIR"
                                    $DQ2LS -P -L ROAMING -T $PCTGTDIR
                                    let gprc=$gprc+$?
                                fi
                            done
                        else
                            msgOut ERROR "No topdir defined for $SETYPE storage type"
                        fi
                    fi

                    # Fix for gsidcap entries in the PFC
                    #if [ -s PoolFileCatalog.xml -a $gprc -eq 0 ] ; then
                    #    GSIDCAPPFCS="`grep 'gsidcap:/' PoolFileCatalog.xml | grep -v gfal | wc -l`"
                    #    if [ $GSIDCAPPFCS -gt 0 ] ; then
                    #        msgOut WARNING "Fixing $GSIDCAPPFCS gsidcap PFC entries"
                    #        sed -i 's#gsidcap:/#gfal:gsidcap:/#g' PoolFileCatalog.xml
                    #    fi
                    #    GSIDCAPPFCS="`grep 'gsidcap:/' PoolFileCatalog.xml | grep -v gfal | wc -l`"
                    #    if [ $GSIDCAPPFCS -gt 0 ] ; then
                    #        msgOut ERROR "$GSIDCAPPFCS PFC entries still using gsidcap direct access"
                    #        gprc=1
                    #    else
                    #        msgOut INFO "gsidcap PFC entries fixed"
                    #    fi
                    #fi

                    # Check for wrong srm entries in the PFC
                    if [ -s PoolFileCatalog.xml -a $gprc -eq 0 ] ; then
                        INVALIDPFCS="`grep 'srm:/' PoolFileCatalog.xml | wc -l`"
                        if [ $INVALIDPFCS -gt 0 ] ; then
                            msgOut ERROR "$INVALIDPFCS PFC entries using the srm protocol, invalid PFC"
                            gprc=1
                        fi
                    fi
    
                    # Early formal check of the PFC
                    if [ -s PoolFileCatalog.xml -a $gprc -eq 0 ] ; then
                        python -c "import xml.dom.minidom;xml.dom.minidom.parse('PoolFileCatalog.xml')"
                        if [ $? -ne 0 ] ; then
                            msgOut ERROR "Cannot parse the temporary PFC, invalid or corrupted data"
                            gprc=1
                        fi
                    fi

                    # Early pfn count on the PFC and comparison with the installed copy
                    if [ -s "PoolFileCatalog.xml" -a -s "${PFCDIR}/PoolFileCatalog.xml" -a $gprc -eq 0 ] ; then
                        PFNOLDCOUNT="`sed -n 's#.*<pfn.*name="\(.*\)".*#\1#p' ${PFCDIR}/PoolFileCatalog.xml | wc -l`"
                        PFNNEWCOUNT="`sed -n 's#.*<pfn.*name="\(.*\)".*#\1#p' PoolFileCatalog.xml | wc -l`"
                        if [ $PFNNEWCOUNT -lt $PFNOLDCOUNT ] ; then
                            msgOut ERROR "The new PFC contains $PFNNEWCOUNT entries while the last one has $PFNOLDCOUNT: invalid data"
                            gprc=1
                        fi
                    fi

                    # Install the PFC
                    if [ -s PoolFileCatalog.xml ] ; then
                        if [ $gprc -eq 0 ] ; then
                            chmod a+r PoolFileCatalog.xml
                            msgOut INFO "PoolFileCatalog.xml generated successfully. Installing in $PFCDIR"
                            # Rotate the PFC files, keep 10 copies
                            filerotate $PFCDIR/PoolFileCatalog.xml 10 1
                            #let gprc=$gprc+$?
                            mv -f $PFCTMPDIR/PoolFileCatalog.xml $PFCDIR
                            let gprc=$gprc+$?
                            [ $gprc -ne 0 ] && msgOut ERROR "Cannot install PFC"
                            cd $PFCDIR; rm -fr $PFCTMPDIR
                            if [ -z "$SKIPLOCALCONF" ] ; then
                                SITECONF="`getRWpath ${SITECONF}`"
                                if [ "`grep "^export ATLAS_POOLCOND_PATH=" ${SITECONF} 2>/dev/null | cut -d'=' -f 2-`" != "`dirname $PWD`" ] ; then
                                    PCPATH="`dirname $PWD`"
                                    PCPATH="`getROpath $PCPATH`"
                                    msgOut INFO "Setting ATLAS_POOLCOND_PATH=$PCPATH in ${SITECONF}"
                                    if [ -s "${SITECONF}" ] ; then
                                        cp -f ${SITECONF} ${SITECONF}.orig
                                        cat ${SITECONF}.orig | grep -v "^export ATLAS_POOLCOND_PATH=" > ${SITECONF}
                                    fi
                                    echo "export ATLAS_POOLCOND_PATH=$PCPATH" >> ${SITECONF}
                                    let gprc=$gprc+$?
                                    [ $gprc -ne 0 ] && msgOut ERROR "Cannot write into ${SITECONF}"
                                fi
                            fi
                            # Post PFC creation handler
                            if [ $gprc -eq 0 -a -n "${SITECONF}" ] ; then
                                unset postCreatePFC
                                eval $(LANG=C fgrep -i "postCreatePFC=" ${SITECONF} 2>/dev/null)
                                if [ "$postCreatePFC" != "" ] ; then
                                    msgOut INFO "Executing post PFC processing script $postCreatePFC"
                                    $postCreatePFC
                                    let gprc=$gprc+$?
                                    [ $gprc -ne 0 ] && msgOut ERROR "PFC post processing failed, err code $gprc"
                                fi
                            fi
                        else
                            msgOut ERROR "PoolFileCatalog.xml invalid or corrupted. Saving a copy in $PFCDIR/PoolFileCatalog.xml.failed"
                            mv -f $PFCTMPDIR/PoolFileCatalog.xml $PFCDIR/PoolFileCatalog.xml.failed
                            let gprc=6
                        fi
                    else
                        msgOut ERROR "PoolFileCatalog.xml not created or empty"
                        let gprc=2
                    fi
                fi
                cd $PFCDIR; rm -fr $PFCTMPDIR
            else
                msgOut ERROR "Cannot create $PFCTMPDIR"
                let gprc=3
            fi
        else
            msgOut ERROR "No DDM site specified"
            let gprc=4
        fi
    else
        msgOut ERROR "No Poolcond pattern specified"
        let gprc=5
    fi

    # Remove the dq2 configuration overrides
    if [ -s $TOPDIR/dq2.cfg ] ; then
        msgOut INFO "Removing the DQ2 configuration override"
        rm -fr ~/.dq2
    fi

    return $gprc
}


unsetLocalConfig() {
    let unsetlcrc=0
    if [ "$LOCALCONF" != "" ] ; then
        LOCALCONF="`getRWpath ${LOCALCONF}`"
        msgOut INFO "Removing $LOCALCONF"
        rm -fr $LOCALCONF
        let unsetlcrc=$?
        [ $unsetlcrc -eq 0 ] && msgOut INFO "Removal successful" || msgOut ERROR "Cannot remove $LOCALCONF"
    else
        msgOut WARNING "No local configuration area specified"
    fi
    return $unsetlcrc
}


setLocalConfig() {
    let setlcrc=0

    # Setup the DDM
    if [ -z "$DQ2_HOME" -a -n "$DDMSETUP" ] ; then
        source $DDMSETUP
        if [ $? -eq 0 ] ; then
            msgOut INFO "DDM configured from $DDMSETUP"
        else
            msgOut ERROR "Cannot configure DDM from $DDMSETUP"
        fi
    fi

    # Guess the emi-version file location
    [ -n "$GLITE_LOCATION" ] && EMIVERSION="`readlink -f $GLITE_LOCATION/../etc/emi-version`" || EMIVERSION="/etc/emi-version"
    msgOut INFO "GLITE_LOCATION=$GLITE_LOCATION ==> EMIVERSION=$EMIVERSION"

    # Override the dq2 configuration if a file dq2.cfg in present in the current working dir or in the installation top dir
    if [ -n "$DQ2_HOME" ] ; then
        if [ -s $TOPDIR/dq2.cfg ] ; then
            DQ2OVERRIDE="$TOPDIR/dq2.cfg"
        elif [ -s $INSTALLER_HOME/dq2.cfg ] ; then
            DQ2OVERRIDE="$INSTALLER_HOME/dq2.cfg"
        else
            msgOut INFO "No DQ2 overrides found in $TOPDIR or $INSTALLER_HOME"
        fi
        if [ -n "$DQ2OVERRIDE" ] ; then
            msgOut INFO "Overriding the default DQ2 configuration with ~/.dq2/etc/dq2.cfg"
            mkdir -p ~/.dq2/etc
            cp $DQ2OVERRIDE ~/.dq2/etc
            msgOut INFO "DQ2URL: `grep '^url=' ~/.dq2/etc/dq2.cfg`"
            [ -f /var/tmp/.dq2${USER}/ToACache.py ] && rm -f /var/tmp/.dq2${USER}/ToACache.py
        fi
    fi

    # Set up the ddm helper
    if [ "$DDMHELPER" == "" ] ; then
        setDDMhelper
        let setlcrc=$?
        [ $setlcrc -ne 0 ] && return $setlcrc
    fi

    # Generate the local site setup
    if [ "$LOCALCONF" != "" ] ; then
        LOCALCONF="`getRWpath ${LOCALCONF}`"
        SITECONF="`getRWpath ${SITECONF}`"
        [ ! -d ${LOCALCONF} ] && mkdir -p ${LOCALCONF}
        [ ! -d ${LOCALCONF}/lib ] && mkdir -p ${LOCALCONF}/lib
        [ ! -d ${LOCALCONF}/lib64 ] && mkdir -p ${LOCALCONF}/lib64
        [ ! -d ${LOCALCONF}/emi/lib ] && mkdir -p ${LOCALCONF}/emi/lib
        [ ! -d ${LOCALCONF}/emi/lib64 ] && mkdir -p ${LOCALCONF}/emi/lib64
        TMPLOCALSETUP=${LOCALCONF}/setup.sh.tmp
        LOCALSETUP=${LOCALCONF}/setup.sh

        # Wait for previous installation process completion
        set -o noclobber
        lock_retries=0
        max_lock_retries=360
        lock_retry_sleep=10
        while [ $lock_retries -lt $max_lock_retries ] ; do
            echo "# Local setup" 2> /dev/null > $TMPLOCALSETUP
            lsr=$?
            if [ $lsr -ne 0 ] ; then
                msgOut WARNING "Cannot lock the installation area, waiting ${lock_retry_sleep}s"
                let lock_retries=$lock_retries+1
                sleep ${lock_retry_sleep}s
            else
                break
            fi
        done
        set +o noclobber
        if [ $lsr -ne 0 ] ; then
            msgOut ERROR "Cannot lock the installation area after $lock_retries retries"
            return 110
        fi
        msgOut INFO "Creating the local setup"

        echo '[ -n "$GLITE_LOCATION" ] && EMIVERSION="`readlink -f $GLITE_LOCATION/../etc/emi-version`" || EMIVERSION="/etc/emi-version"' >> $TMPLOCALSETUP
        [ "$DDMSITE" == "" -a "$DQ2_LOCAL_SITE_ID" != "" ] && DDMSITE="`echo $DQ2_LOCAL_SITE_ID | sed 's/\(.*\)_\(.*\)/\1_HOTDISK/'`"
        [ "$GOCNAME" == "" -a "$DDMSITE" != "" ] && GOCNAME="`echo $DDMSITE | sed 's/\(.*\)_\([^_]*\)/\1/'`"
        if [ -n "$GOCNAME" ] ; then
            if [ -n "$DDMHELPER" ] ; then
                if [ -s $DDMHELPER ] ; then
                    msgOut INFO "Getting Frontier setup for $GOCNAME using python $DDMHELPER $GOCNAME"
                    FRONTIER_SETUP="`python $DDMHELPER $GOCNAME`"
                    ddmrc=$?
                    if [ -z "$FRONTIER_SETUP" ] ; then
                        msgOut INFO "No Frontier settings found. Trying with $DDMHELPER ${GOCNAME}_INSTALL."
                        FRONTIER_SETUP="`python $DDMHELPER ${GOCNAME}_INSTALL`"
                        ddmrc=$?
                    fi
                    let setlcrc=$setlcrc+$ddmrc
                else
                    msgOut ERROR "No DDM helper found"
                fi
                msgOut WARNING "No DDM helper defined"
            fi
            if [ -n "$FRONTIER_SETUP" ] ; then
                msgOut INFO "Frontier setup for $GOCNAME is $FRONTIER_SETUP"
            else
                msgOut WARNING "Frontier setup for $GOCNAME is empty"
            fi
            msgOut INFO "Using siteconf $SITECONF"
            eval $(LANG=C fgrep "ATLAS_POOLCOND_PATH=" ${SITECONF})
            if [ "$ATLAS_POOLCOND_PATH" != "" ] ; then
                msgOut INFO "ATLAS_POOLCOND_PATH for $GOCNAME is $ATLAS_POOLCOND_PATH"
            else
                msgOut ERROR "ATLAS_POOLCOND_PATH for $GOCNAME is empty"
                # This is a fatal error if we have a Frontier configuration
                [ "$FRONTIER_SETUP" != "" ] && setlcrc=1
            fi
        else
            msgOut ERROR "No DDM site specified"
            setlcrc=2
        fi
        if [ -s "${LOCALSETUP}" ] ; then
            cp -f ${LOCALSETUP} ${LOCALSETUP}.orig
            if [ $? -ne 0 ] ; then
                msgOut ERROR "Cannot make a backup copy of ${LOCALSETUP}"
                setlcrc=10
            fi
        fi
        if [ "$ATLAS_POOLCOND_PATH" != "" ] ; then
            echo "export ATLAS_POOLCOND_PATH=\"${ATLAS_POOLCOND_PATH}\"" >> ${TMPLOCALSETUP}
            let setlcrc=$setlcrc+$?
        fi
        if [ "$FRONTIER_SETUP" != "" ] ; then
cat >> ${TMPLOCALSETUP} <<EOD
export FRONTIER_SERVER="${FRONTIER_SETUP}"
export FRONTIER_LOG_LEVEL=warning
#export FRONTIER_READTIMEOUTSECS=60
EOD
            let setlcrc=$setlcrc+$?
        fi
        [ $setlcrc -ne 0 ] && msgOut ERROR "Cannot write into ${TMPLOCALSETUP}"

        # Try to detect the se type from the DDM
        if [ -n "$DDMHELPER" -a -s $DDMHELPER ] ; then
            SETYPE="`python $DDMHELPER --setype $DDMSITE | tr a-z A-Z`"
        fi
        [ -n "$SETYPE" ] && msgOut INFO "Setting configuration for storage type $SETYPE"

        # Check if this is not a DPM site and apply the dcache fixes
        if [ -z "$DPM_HOST" -a "$SETYPE" != "DPM" ] ; then
            msgOut INFO "This is not a DPM site. Applying the dcache fixes."
            echo "# dcache setup" >> ${TMPLOCALSETUP}
            echo "export DCACHE_RAHEAD=TRUE" >> ${TMPLOCALSETUP}
            echo "export DCACHE_RA_BUFFER=32768" >> ${TMPLOCALSETUP}
            echo "export DC_LOCAL_CACHE_BUFFER=1" >> ${TMPLOCALSETUP}
            echo "export DC_LOCAL_CACHE_BLOCK_SIZE=131072" >> ${TMPLOCALSETUP}
            echo "export DC_LOCAL_CACHE_MEMORY_PER_FILE=10000000" >> ${TMPLOCALSETUP}

            for MWDIR in "" "/emi"; do
                for LIBTYPE in 32 64; do
                    msgOut INFO "Installing the $LIBTYPE bits libdcap from ${DCAPURL[$LIBTYPE]}"
                    [ "$LIBTYPE" == 32 ] && cd ${LOCALCONF}${MWDIR}/lib || cd ${LOCALCONF}${MWDIR}/lib64
                    rm -f ${LIBNAME}.new
                    LIBNAME="`basename ${DCAPURL[$LIBTYPE]}`"
                    wget --no-verbose ${DCAPURL[$LIBTYPE]} -O ${LIBNAME}.new
                    if [ $? -eq 0 -a -s ${LIBNAME}.new ] ; then
                        chmod +x ${LIBNAME}.new
                        mv -f ${LIBNAME}.new ${LIBNAME}
                        msgOut INFO "Updated $LIBTYPE bits $LIBNAME installed successfully in $PWD (`du -k ${LIBNAME} | awk '{print $1}'`k)"
                    else
                        msgOut WARNING "Failed to get ${DCAPURL[$LIBTYPE]}"
                        rm -f ${LIBNAME}.new
                        setlcrc=4
                    fi
                    cd -
                done
            done
        elif [ "$SETYPE" == "STORM" -o "$SETYPE" == "CASTOR" ] ; then
            msgOut INFO "No patches needed for $SETYPE SE type."
        else
            for MWDIR in "" "/emi"; do
                if [ -f $EMIVERSION -a -z "$MWDIR" ] ; then
                    msgOut INFO "This is possibly a DPM site, guessing the glite rfio libraries from an emi node."
                    cd ${LOCALCONF}${MWDIR}/lib
                    LIBDPM32="/opt/lcg/lib/libdpm.so"
                    [ ! -f libshift.so ] && ln -sf $LIBDPM32 libshift.so
                    [ ! -f libshift.so.2.1 ] && ln -sf $LIBDPM32 libshift.so.2.1
                    cd -
                    cd ${LOCALCONF}${MWDIR}/lib64
                    LIBDPM64="/opt/lcg/lib64/libdpm.so"
                    [ ! -f libshift.so ] && ln -sf $LIBDPM64 libshift.so
                    [ ! -f libshift.so.2.1 ] && ln -sf $LIBDPM64 libshift.so.2.1
                elif [ ! -f $EMIVERSION -a "$MWDIR" == "/emi" ] ; then
                    msgOut INFO "This is possibly a DPM site, guessing the emi rfio libraries from a glite node."
                    cd ${LOCALCONF}${MWDIR}/lib
                    LIBDPM32="/usr/lib/libdpm.so"
                    [ ! -f libshift.so ] && ln -sf $LIBDPM32 libshift.so
                    [ ! -f libshift.so.2.1 ] && ln -sf $LIBDPM32 libshift.so.2.1
                    cd -
                    cd ${LOCALCONF}${MWDIR}/lib64
                    LIBDPM64="/usr/lib64/libdpm.so"
                    [ ! -f libshift.so ] && ln -sf $LIBDPM64 libshift.so
                    [ ! -f libshift.so.2.1 ] && ln -sf $LIBDPM64 libshift.so.2.1
                else
                    msgOut INFO "This is possibly a DPM site, fixing the rfio libraries."
                    LIBDPM32="`find $LCG_LOCATION/lib -name 'libdpm.so' -xtype f 2>/dev/null`"
                    if [ -z "$LIBDPM32" ] ; then
                        msgOut WARNING "No i686 libdpm.so link found, trying with the library"
                        LIBDPM32="`find $LCG_LOCATION/lib -name 'libdpm.so.*' -xtype f 2>/dev/null | sort | tail -n 1`"
                    fi
                    if [ -d "$LCG_LOCATION/lib64" ] ; then
                        LIBDPM64="`find $LCG_LOCATION/lib64 -name 'libdpm.so' -xtype f 2>/dev/null`"
                        if [ -z "$LIBDPM64" ] ; then
                            msgOut WARNING "No x86_64 libdpm.so link found, trying with the library"
                            LIBDPM64="`find $LCG_LOCATION/lib64 -name 'libdpm.so.*' -xtype f 2>/dev/null | sort | tail -n 1`"
                        fi
                    fi
                    cd ${LOCALCONF}${MWDIR}/lib
                    if [ -n "$LIBDPM32" ] ; then
                        ln -sf $LIBDPM32 libshift.so
                        ln -sf $LIBDPM32 libshift.so.2.1
                    else
                        msgOut WARNING "Cannot find the 32 bits libdpm.so in LCG_LOCATION/lib ($LCG_LOCATION/lib)"
                    fi
                    cd -
                    cd ${LOCALCONF}${MWDIR}/lib64
                    if [ -n "$LIBDPM64" ] ; then
                        ln -sf $LIBDPM64 libshift.so
                        ln -sf $LIBDPM64 libshift.so.2.1
                    else
                        msgOut WARNING "Cannot find the 64 bits libdpm.so in LCG_LOCATION/lib64 ($LCG_LOCATION/lib64)"
                    fi
                fi
                if [ ! -f $EMIVERSION ] ; then
                    GSSAPILIBNAME=([32]="libglobus_gssapi_gsi_gcc32dbgpthr.so" [64]="libglobus_gssapi_gsi_gcc64dbgpthr.so")
                    GSSAPILIBLOCAL="libglobus_gssapi_gsi.so"
                    for LIBTYPE in 32 64; do
                        msgOut INFO "Fixing ${GSSAPILIBNAME[$LIBTYPE]}"
                        [ "$LIBTYPE" = "32" ] && LIBDIR="lib" || LIBDIR="lib64"
                        if [ -f $GLOBUS_LOCATION/$LIBDIR/${GSSAPILIBNAME[$LIBTYPE]} ] ; then
                            GSSAPILIB="$GLOBUS_LOCATION/$LIBDIR/${GSSAPILIBNAME[$LIBTYPE]}"
                        elif [ -f $LCG_LOCATION/$LIBDIR/${GSSAPILIBNAME[$LIBTYPE]} ] ; then
                            GSSAPILIB="$LCG_LOCATION/$LIBDIR/${GSSAPILIBNAME[$LIBTYPE]}"
                        fi
                        if [ -f $GSSAPILIB ] ; then
                            GSSAPILIBARCH="`file -L $GSSAPILIB | sed 's/.*ELF \([0-9]*\)-bit.*/\1/'`" || GSSAPILIBARCH=0
                            msgOut INFO "Found a ${GSSAPILIBARCH}-bit ${GSSAPILIBNAME[$LIBTYPE]} library in ${GSSAPILIB}"
                        fi
                        if [ -n $GSSAPILIB -a "${GSSAPILIBARCH}" = "${LIBTYPE}" ] ; then
                            msgOut INFO "Linking the ${LIBTYPE}-bit ${GSSAPILIBNAME[$LIBTYPE]} library to ${LOCALCONF}/$LIBDIR/${GSSAPILIBLOCAL}"
                            ln -sf $GSSAPILIB ${LOCALCONF}/$LIBDIR/${GSSAPILIBLOCAL}
                            msgOut INFO "`file -L ${LOCALCONF}/$LIBDIR/${GSSAPILIBLOCAL}`"
                        else
                            # Install a fake library partner to avoid problems with LD_PRELOAD
                            msgOut INFO "Installing a fake ${LIBTYPE}-bit ${GSSAPILIBLOCAL} library in ${LOCALCONF}/${LIBDIR}"
                            msgOut INFO "gcc -shared -fpic -o ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL} -xc /dev/null -m${LIBTYPE}"
                            gcc -shared -fpic -o ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}.new -xc /dev/null -m${LIBTYPE}
                            if [ -s ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}.new ] ; then
                                [ -f ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL} ] && cp -f ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL} ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}.save
                                mv -f ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}.new ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}
                                msgOut INFO "`file ${LOCALCONF}/${LIBDIR}/${GSSAPILIBLOCAL}`"
                            fi
                        fi
                    done
                fi
            done
            if [ -f "${LOCALCONF}/lib/${GSSAPILIBLOCAL}" ] ; then
                LOCALCONFRO="`getROpath ${LOCALCONF}`"
                echo 'if [ ! -f $EMIVERSION ] ; then' >> ${TMPLOCALSETUP}
                echo "    export LD_PRELOAD=${LOCALCONFRO}/'\$LIB'/${GSSAPILIBLOCAL}" >> ${TMPLOCALSETUP}
                echo "fi" >> ${TMPLOCALSETUP}
            else
                msgOut INFO "Cannot find ${LOCALCONF}/lib/${GSSAPILIBLOCAL}"
            fi
            cd -
            [ -d "${LOCALCONF}/lib" ]   && msgOut INFO "Local lib listing (${LOCALCONF}/lib): `\ls -l ${LOCALCONF}/lib`"
            [ -d "${LOCALCONF}/lib64" ] && msgOut INFO "Local lib listing (${LOCALCONF}/lib64): `\ls -l ${LOCALCONF}/lib64`"
        fi
        LOCALCONFRO="`getROpath ${LOCALCONF}`"
        LOCALSETUPRO="`getROpath ${LOCALSETUP}`"
        echo 'if [ -f $EMIVERSION ] ; then' >> ${TMPLOCALSETUP}
        echo "    export LD_LIBRARY_PATH=${LOCALCONFRO}${MWDIR}/lib:${LOCALCONFRO}${MWDIR}/lib64:\$LD_LIBRARY_PATH" >> ${TMPLOCALSETUP}
        echo "else" >> ${TMPLOCALSETUP}
        echo "    export LD_LIBRARY_PATH=${LOCALCONFRO}/lib:${LOCALCONFRO}/lib64:\$LD_LIBRARY_PATH" >> ${TMPLOCALSETUP}
        echo "fi" >> ${TMPLOCALSETUP}
        if [ "$SWAREAFS" != "cvmfs" ] ; then
            # Set the cctools path override only for non CVMFS sites, as cctools are already in the CVMFS repo
            echo "[ -f `dirname ${LOCALCONF}`/cctools/latest/setup.sh ] && source `dirname ${LOCALCONF}`/cctools/latest/setup.sh" >> ${TMPLOCALSETUP}
        fi
        echo "# allow local override at end" >> ${TMPLOCALSETUP}
        echo "[ -f ${LOCALSETUPRO}.local ] && source ${LOCALSETUPRO}.local" >> ${TMPLOCALSETUP}
        [ "$GRIDNAME" == "OSG" ] && echo 'export VOMS_PROXY_INFO_DONT_VERIFY_AC="true"' >> ${TMPLOCALSETUP}
        if [ $setlcrc -eq 0 ] ; then
            # Move the temporary local setup file to the final location
            msgOut INFO "Local setup installation completed, moving ${TMPLOCALSETUP} to ${LOCALSETUP}"
            mv -f ${TMPLOCALSETUP} ${LOCALSETUP}
            if [ $? -eq 0 ] ; then
                msgOut INFO "Local configuration file:"
                msgOut INFO "`cat ${LOCALSETUP}`"
            else
                msgOut ERROR "Cannot move ${TMPLOCALSETUP} to ${LOCALSETUP}"
                rm -f ${TMPLOCALSETUP}
                setlcrc=6
            fi
        else
            rm -f ${TMPLOCALSETUP}
            msgOut ERROR "Error creating local setup scripts. Rejecting changes."
        fi
    else
        msgOut ERROR "No local configuration area specified"
        setlcrc=5
    fi

    # Remove the dq2 configuration overrides
    if [ -s $TOPDIR/dq2.cfg ] ; then
        msgOut INFO "Removing the DQ2 configuration override"
        rm -fr ~/.dq2
    fi

    return $setlcrc
}


# Query the cached releases
query() {
    let queryrc=0
    mode="${1}"
    if [ "$mode" != "-quiet" ] ; then
        printf "List of releases available locally:\n"
        printf "===========================================================================\n"
        printf "| %12s | %10s | %20s | %20s |\n" "Type" "Version" "Architecture" "Date/Time"
        printf "===========================================================================\n"
    fi
    ATLVER_1=""
    ATLVER_2=""
    TMPFILE="/tmp/tmp.query.$$"
    for snap in `\ls -d $SNAPDIR/*.snap* 2>/dev/null` ; do
        snapname="`echo $snap | awk -F '-' '{print $2"-"$(NF-3)"-"$(NF-1)}' | sed 's/\.snap//g'`"
        ATLTYPE="`echo $snapname | cut -d '-' -f 1`"
        ATLVER="`echo $snapname | cut -d '-' -f 2`"
        ATLARCH="`echo $snapname | cut -d '-' -f 3`"
        ATLDT="`stat -c %y $snap 2>&1 | cut -d '.' -f 1`"
        if [ "$mode" != "-quiet" ] ; then
            printf "| %12s | %10s | %20s | %20s |\n" "$ATLTYPE" "$ATLVER" "$ATLARCH" "$ATLDT" >> $TMPFILE
        fi
        [ "$ATLVER_1" == "" ] && ATLVER_1="$ATLVER"
        ATLVER_2="$ATLVER"
    done
    cat $TMPFILE 2> /dev/null | sort -n -k 2
    rm -f $TMPFILE
    if [ "$mode" != "-quiet" ] ; then
        printf "===========================================================================\n"
    else
        if [ "${ATLVER_1}" != "${ATLVER_2}" ] ; then
            echo "${ATLVER_1}_${ATLVER_2}"
        else
            echo "${ATLVER_1}"
        fi
    fi
    return $queryrc
}


writeDVD() {
    let writedvdrc=0
    image="${1}"
    CDRECORD="cdrecord"
    CDSCAN="$CDRECORD -scanbus"
    CDWRITE="$CDRECORD -v -eject -dao"
    TMPSCAN=/tmp/tmp.scan.$$
    $CDSCAN 2>&1 \
            | awk '/.,.,..*CD-ROM/ {indx+=1; print "["indx"] "$0}' > $TMPSCAN
    cat $TMPSCAN
    echo -n "Please choose a device to write: "
    read dev
    DEV_ADDR="`grep \"^\[$dev\]\" $TMPSCAN | cut -f 2`"
    echo "Device $DEV_ADDR selected for writing..."
    rm -fr $TMPSCAN
    $CDWRITE dev=ATA:${DEV_ADDR} "${image}"
    let writedvdrc=$writedvdrc+$?
    return $writedvdrc
}


mkiso() {
    let mkisorc=0
    MKISOFS="mkisofs"
    image="${1}"
    volume="${2}"
    preparer="${3}"
    inpath="${4}"
    TMPDIR=/tmp/tmp.mkiso.$$
    mkdir "$TMPDIR"
    cd "$TMPDIR"
    ln -sf "$inpath" .
    cd "$TOPDIR"
    $MKISOFS -f -J -r -o "$image" -V "$volume" -p "$preparer" -m "*.gz" $TMPDIR
    rm -fr $TMPDIR
    echo "Do you want to write a DVD [Y/n] ?"
    read dowrite
    if [ "$dowrite" == "" -o "$dowrite" == "Y" -o "$dowrite" == "y" ] ; then
        writeDVD $image
    else
        echo "The DVD image $image has been created successfully"
    fi
    let mkisorc=$mkisorc+$?
    return $mkisorc
}

cleanup() {
    let cleanrc=0
    RELLOC="`getRWpath ${RELLOC}`"
    SWLOC="`getRWpath ${SWLOC}`"
    LOCKFILE="${RELLOC}/atlas-install.lock"

    # Main release version
    MAINRELVER="`echo $RELEASE | awk -F "." '{for (i=1;i<=3;i++) ver=sprintf("%s%02d",ver,$i)}END{print int(ver)}'`"

    if [ -f ${SWLOC}/setup.sh ] ; then
      if [ -s "${SWLOC}/cmtsite/asetup.sh" -a $MAINRELVER -ge 160000 ] ; then
          SITEROOT="`(source ${SWLOC}/cmtsite/asetup.sh &> /dev/null;echo $SITEROOT)`"
      fi
      if [ "$SITEROOT" == "" -a -s "${SWLOC}/cmtsite/setup.sh" ] ; then
          SITEROOT="`(source ${SWLOC}/cmtsite/setup.sh &> /dev/null;echo $SITEROOT)`"
      fi
      if [ "$SITEROOT" == "" ] ; then
          SITEROOT="`(source ${SWLOC}/setup.sh &> /dev/null;echo $SITEROOT)`"
      fi
      if [ "$SITEROOT" == "" ] ; then
          msgOut WARNING "Empty SITEROOT. The current installation is possibly corrupted. Resetting SITEROOT to ${RELLOC}"
          SITEROOT="${RELLOC}"
      fi
      [ -n "$PHYSLINK" -a "`readlink -f $RELLOC`" == "$PHYSLINK" ] && SITEROOT="$RELLOC"
      SITEROOT="`getRWpath ${SITEROOT}`"
      if [ "${RELLOC}" != "${SWLOC}" -a "${RELLOC}" != "`echo ${SITEROOT} | sed 's#\.r[0-9]*$##g'`" ] ; then
        msgOut INFO "The logical installation points to a different SITEROOT (expected: ${RELLOC}, actual: ${SITEROOT}). I will not delete ${SWLOC}"
        SWLOC="none"
      fi
      LOCKFILE="`readlink -f ${SITEROOT}/atlas-install.lock`"
    fi

    # Wait for previous installation process completion
    if [ -f ${LOCKFILE} ] ; then
        msgOut WARNING "Another installation process is currently active. Now waiting..."
        waittime=0
        while `test -f ${LOCKFILE}`; do
            sleep 1s
            let waittime=$waittime+1
            if [ $waittime -gt 3600 ] ; then
                msgOut WARNING "Timeout [3600 s]"
                msgOut WARNING "Removing stale installation lock"
                rm -f ${LOCKFILE}
            fi
        done
    fi
    msgOut INFO "Locking the installation area"
    echo "$RELEASE installation lock" > ${LOCKFILE}
    case `whoami` in
        usatlas*) msgOut INFO "This is an OSG site with static accounts. No further action required"
            ;;
        *[0-9])
            msgOut INFO "This site is configured for SGM pool accounts. Changing group permissions to ${LOCKFILE}"
            chmod -R g+rw ${LOCKFILE} 2>/dev/null
            [ $? -ne 0 ] && msgOut ERROR "Cannot change group write permissions to ${LOCKFILE}"
        ;;
    esac

    # Clean the site config
    SITECONF="`getRWpath ${SITECONF}`"
    if [ "$PRJTYPE" == "poolcond" -a "`grep "^export ATLAS_POOLCOND_PATH" 2>/dev/null ${SITECONF}`" != "" ] ; then
        msgOut INFO "Removing ATLAS_POOLCOND_PATH from ${SITECONF}"
        cp -f ${SITECONF} ${SITECONF}.orig
        cat ${SITECONF}.orig | grep -v "^export ATLAS_POOLCOND_PATH" > ${SITECONF}
        [ ! -s ${SITECONF} ] && rm -f ${SITECONF}
    fi

    # Clean the local config
    [ "$PRJTYPE" == "poolcond" -a "$GRIDNAME" != "NORDUGRID" ] && unsetLocalConfig

    # Clean up the compiler configuration
    [ "$PRJTYPE" == "ext" -a "$PRJNAME" == "gcc" ] && unsetCompiler

    # Clean the release
    if [ "$REINSTALL" != "yes" ] ; then
      if [ "${SWLOC}" != "${RELLOC}" ] ; then
        if [ -d ${SWLOC} ] ; then
          msgOut INFO "Removing $SWLOC"
          SWLOCBEFORE="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
          [ "$SWLOCBEFORE" == "" ] && SWLOCBEFORE=0
          rm -fr $SWLOC
          let swclean=$?
          let cleanrc=$cleanrc+$swclean
          [ $swclean -ne 0 ] && msgOut ERROR "An error occurred while removing ${SWLOC}"
          SWLOCAFTER="`du -sk ${SWLOC} 2>/dev/null | awk '{print $1}'`"
          [ "$SWLOCAFTER" == "" ] && SWLOCAFTER=0
          msgOut INFO "Disk space saved: `echo $((${SWLOCBEFORE}-${SWLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
        else
          msgOut INFO "No directory ${SWLOC} found"
        fi
      fi
    fi

    if [ "$REINSTALL" != "yes" ] ; then
      RELLOCS="`\ls -d ${RELLOC} ${RELLOC}.r* 2>/dev/null`"
    else
      [ "$SITEROOT" == "" ] && SITEROOT="$RELLOC"
      msgOut INFO "Skipping $SITEROOT"
      RELLOCS="`\ls -d ${RELLOC} ${RELLOC}.r* 2>/dev/null | grep -v $SITEROOT`"
    fi
    for RLOC in ${RELLOCS} ; do
      msgOut INFO "Removing $RLOC"
      RELLOCBEFORE="`du -sk ${RLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$RELLOCBEFORE" == "" ] && RELLOCBEFORE=0
      # Physically remove the installation directory
      # Check if we're running in AFS and correct the installation path and removal method, if needed
      if [ "`isAFSpath $RLOC`" == "yes" ] ; then
          msgOut INFO "Removing data from volume $RLOC"
          AFSREMOVE="`which afs_remove 2>/dev/null`"
          AFSMP="`isAFSmountpoint $RLOC`"
          if [ "$AFSMP" != "" ] ; then
              if [ "$AFSREMOVE" != "" ] ; then
                  msgOut INFO "Destroying the volume using $AFSREMOVE"
                  $AFSREMOVE $RLOC
                  let relclean=$?
              else
                  # Removing the directory contents
                  msgOut INFO "No afs_remove found. Removing the contents of $RLOC"
                  rm -fr $RLOC/*
                  let relclean=$?
                  # Removing the directory itself, if this fails it's not a fatal error
                  rmdir $RLOC
                  [ $? -ne 0 ] && msgOut WARNING "Cannot remove the directory $RLOC"
              fi
          else
              # Remove the orphaned directory
              msgOut WARNING "$RLOC is not an AFS mountpoint. Will remove it"
              rm -fr $RLOC
              let relclean=$?
          fi
      else
          # Non-AFS filesystems
          rm -fr $RLOC
          let relclean=$?
      fi
      let cleanrc=$cleanrc+$relclean
      [ $relclean -ne 0 ] && msgOut ERROR "An error occurred while removing ${RLOC}"
      RELLOCAFTER="`du -sk ${RLOC} 2>/dev/null | awk '{print $1}'`"
      [ "$RELLOCAFTER" == "" ] && RELLOCAFTER=0
      msgOut INFO "Disk space saved: `echo $((${RELLOCBEFORE}-${RELLOCAFTER})) | awk '{printf "%7.1f", $1/1024}'` MB"
    done
    if [ "$RELLOCS" == "" ] ; then
      msgOut INFO "No directory ${RELLOC} or ${RELLOC}.r* found or the directory is in use and you request to cleanup after a reinstallation"
    fi

    # Remove the logical area link
    if [ -n "$LOGLINK" ] ; then
        if [ -L "$LOGLINK" ] ; then
            msgOut INFO "Removing link ${LOGLINK}"
            rm -f ${LOGLINK}
        else
            msgOut INFO "${LOGLINK} not found"
        fi
        if [ -d "$LOGLINK" ] ; then
            if [ "$CLEANLINKS" == "yes" ] ; then
                msgOut INFO "Removing directory ${LOGLINK}"
                rm -fr ${LOGLINK}
            else
                msgOut WARNING "Directory ${LOGLINK} found, but no link cleaning requested"
            fi
        fi
    fi

    # Remove the physical area link
    if [ -n "$PHYSLINK" ] ; then
        if [ -L "$PHYSLINK" -o -n "$CLEANLINKS" ] ; then
            msgOut INFO "Removing link ${PHYSLINK}"
            rm -f ${PHYSLINK}
        else
            msgOut INFO "${PHYSLINK} not found"
        fi
        if [ -d "$PHYSLINK" ] ; then
            if [ "$CLEANLINKS" == "yes" ] ; then
                msgOut INFO "Removing directory ${PHYSLINK}"
                rm -fr ${PHYSLINK}
            else
                msgOut WARNING "Directory ${PHYSLINK} found, but no link cleaning requested"
            fi
        fi
    fi

    # End of function, check for errors
    if [ $cleanrc -ne 0 ] ; then
        msgOut ERROR "Cannot remove the installation directories"
    else
        msgOut INFO "Cleanup OK"
    fi

    # List the software area contents
    RELLOCPATH="`dirname ${RELLOC}`" 
    if [ "${SWLOC}" != "${RELLOC}" ] ; then
        SWLOCPATH="`dirname ${SWLOC}`" 
        msgOut INFO "Showing contents of the logical installation path (${SWLOCPATH})"
        msgOut INFO "`\ls ${SWLOCPATH}`"
    fi
    msgOut INFO "Showing contents of the physical installation path (${RELLOCPATH})"
    msgOut INFO "`\ls ${RELLOCPATH}`"

    # Unlock the installation area
    msgOut INFO "Unlocking the installation area"
    rm -f ${LOCKFILE}

    return $cleanrc
}

setupPacman() {
    let setuprc=0
    # Save the current directory
    CURDIR=$PWD
    # Use ${TOPDIR} to store pacman
    cd ${TOPDIR}
    # Download/find and install pacman, if needed
    if [ ! -d ${PACMAN_DIR} ] ; then
        msgOut WARNING "Pacman not found in `dirname ${PACMAN_DIR}`"
        if [ ! -s ${PACMAN_TAR} ] ; then
            wget ${PACMAN_URL}/`basename ${PACMAN_TAR}`
            let setuprc=$setuprc+$?
            PACMAN_TAR="$PWD/`basename $PACMAN_TAR`"
            if [ ! -s "${PACMAN_TAR}" ] ; then
                msgOut ERROR "Cannot get pacman ${PACMAN_VER} from ${PACMAN_URL}: ${PACMAN_TAR} not found or empty"
                msgOut INFO "Listing $PWD: `\ls -l`"
                return 50
            fi
        fi
        msgOut INFO "Installing pacman ${PACMAN_VER}"
        tar xfz ${PACMAN_TAR}
        let setuprc=$setuprc+$?
        rm -f ${PACMAN_TAR}
        PACMAN_DIR="$PWD/`basename ${PACMAN_DIR}`"
        cd "${PACMAN_DIR}"
        [ "${PACMAN_PATCH}" != "" -a -s "${PACMAN_PATCH}" ] && \
             patch -p1 < ${PACMAN_PATCH}
        cd "${TOPDIR}"
    fi

    # Setup pacman
    cd "${PACMAN_DIR}"
    source $PWD/setup.sh
    let setuprc=$setuprc+$?
    if [ $setuprc -eq 0 ] ; then
        msgOut INFO "pacman ${PACMAN_VER} installed and set up correctly from ${PACMAN_DIR}."
        if [ "`which pacman 2>/dev/null`" == "" ] ; then
            msgOut ERROR "Cannot find the 'pacman' executable"
            msgOut INFO  "$PWD"
            msgOut INFO  "$PACMAN_LOCATION"
            setuprc=10
        fi
    else
        msgOut ERROR "Unable to setup pacman ${PACMAN_VER}."
    fi
    # Go back to the startup directory
    cd $CURDIR
    return $setuprc
}


autoconfig() {
    # Autoconfiguration
    if [ -n "$AUTOCONF" ] ; then
        AUTOCONF_TMP="/tmp/sw-mgr.$$.autoconf"
        rm -f $AUTOCONF_TMP
        ACURL="https://atlas-install.roma1.infn.it/atlas_install/info/showrel.php"
        msgOut INFO "Autoconfiguring release $AUTOCONF from $ACURL"
        RELINFO="`echo ${AUTOCONF} | sed -e 's/\([^_]\)_\(.*\)\(_i686_slc[0-9]*_gcc[0-9]*\)_\(.*\)/\1 \2 \3/' -e 's/\([^_]\)_\(.*\)\(_x86_64_slc[0-9]*_gcc[0-9]*\)_\(.*\)/\1 \2 \3/'`"
        if [ "$RELINFO" == "${AUTOCONF}" ] ; then
            RELCONFDATA="`curl --connect-timeout 300 -sk  $ACURL?rel=${AUTOCONF}`"
        else
            RELPRJ="`echo $RELINFO | awk '{print $1}'`"
            RELVER="`echo $RELINFO | awk '{print $2}' | sed 's/_/./g'`"
            RELARC="`echo $RELINFO | awk '{print $3}'`"
            RELCONFDATA="`curl --connect-timeout 300 -sk  \"$ACURL?swname=${RELPRJ}&version=${RELVER}&arch=${RELARC}\"`"
        fi
        if [ $? -eq 0 ] ; then
            echo $RELCONFDATA | awk -F ',' '{for (i=1;i<=NF;i++) print $i}' | while read v; do
                vkey="`echo $v | cut -d= -f 1`"
                vval="`echo $v | cut -d= -f 2`"
                if [ -n "$vval" ] ; then
                    case $vkey in
                        RELEASE)       echo "Release Name: $vval";;
                        SWNAME)        echo "Project Name: $vval"
                                       echo PRJNAME=\"$vval\" >> $AUTOCONF_TMP;;
                        PACMANVERSION) echo "Pacman version: $vval"
                                       echo PACMAN_VER=\"$vval\" >> $AUTOCONF_TMP;;
                        DISKSPACE)     echo "Disk free: $vval"
                                       echo MINDF=\"$vval\" >> $AUTOCONF_TMP;;
                        ARCH)          echo "Architecture: $vval"
                                       echo ARCH=\"$vval\" >> $AUTOCONF_TMP;;
                        REQUIREDPRJ)   echo "Required project: $vval"
                                       echo REQPRJNAME=\"$vval\" >> $AUTOCONF_TMP;;
                        DBRELEASE)     DBREL="`echo $vval | sed 's#--dbrelease ##g'`"
                                       echo "DB Release: $DBREL"
                                       echo DBREL=\"$DBREL\" >> $AUTOCONF_TMP;;
                        KITCACHE)      ATLAS="`echo $vval | sed 's#--kit-cache ##g'`"
                                       echo "Kit Cache: $ATLAS"
                                       echo ATLAS=\"$ATLAS\" >> $AUTOCONF_TMP;;
                        RELTAG)        echo "Tag name: $vval"
                                       echo TAGNAME=\"$vval\" >> $AUTOCONF_TMP;;
                        VALIDATE_TASK) TSKNAME="`echo $vval | cut -d '-' -f 2-`"
                                       PRJTYPE="release"
                                       case $TSKNAME in
                                           prod|dev) PRJTYPE="release";;
                                           prod-patch|dev-patch) PRJTYPE="patch";;
                                           dq2tools|gcc) PRJTYPE="ext";;
                                           nightlies) PRJTYPE="`echo $AUTOCONF | cut -d ':' -f 2- | cut -d '-' -f 2- | cut -d '_' -f 2`";;
                                           poolcond) PRJTYPE="poolcond";;
                                           t0-patch) PRJTYPE="t0patch";;
                                           tdaq) PRJTYPE="tdaq";;
                                           prod-analysis|dev-analysis) PRJTYPE="analysis";;
                                       esac
                                       echo "Project Type: $PRJTYPE"
                                       echo PRJTYPE=\"$PRJTYPE\" >> $AUTOCONF_TMP;;
                    esac
                fi
            done
            if [ -s $AUTOCONF_TMP ] ; then
                . $AUTOCONF_TMP
            fi
            [ "$PRJTYPE" == "release" ] && unset REQPRJNAME
            rm -f $AUTOCONF_TMP
            # Only install releases
            PACKOPT="rel"
            # Don't use snapshot caching
            NOCACHE="yes"
        else
            msgOut ERROR "Cannot get auto configuration for release $AUTOCONF from $ACURL"
            exit 100
        fi
        if [ -z "$RELCONFDATA" ] ; then
            msgOut ERROR "Cannot auto configure release $AUTOCONF. Unknown release."
            exit 101
        fi
    fi
}

# MAIN program
msgOut INFO "$VERSION starting"

# Deafults
MKDVD="no"
PACKOPT="all"
PRJNAME="release"
PRJTYPE="release"
PRJOPT="opt"
PACMAN_VER="3.29"
TEMPCACHE="no"
TAGACTION="none"
REGISTER="no"
RELVER="1"
USEGRID="no"
GRIDREPLICA="no"
TAGVO="atlas"
MINDF="6000000:20000:3000000"
MININSTALLSIZE=100000
REQSHAREDFS="no"
XMLFILE=""
T_POST="no"
REINSTALL="no"
UPDATE="no"
EXTRATAG=""
FORCETAGS="no"
KVPOSTTAG=""
KVKEEP="n"
ATLAS=""
QUIET=""
SNAPNAME=""
TESTTHR="1"
USEPACBALL="no"
DEBUG="no"
POSTSITEINFO="no"
POSTSITEURL="https://atlas-install.roma1.infn.it/atlas_install/exec/updinfo.php"
POSTRELURL="https://atlas-install.roma1.infn.it/atlas_install/exec/relstat.php"
GRIDNAME="EGEE"
TAGFILE=""
TAGMODE="grid"
COMPATURL="http://classis01.roma1.infn.it/pacman/packages/sl4_to_sl5"
COMPATPATCH=(patch-slc4-to-slc5-modular.sh AtlasCore_PlatformPolicy.tgz AtlasCore_SLC4_Compat.tgz AtlasLogin.tar.gz AtlasSettings.tar.gz slc4compat.tar.gz)
SL5RTPATCH=(python-2.5.4-i386-md5-libs.tar.gz)
SL5RTURL="http://classis01.roma1.infn.it/pacman/packages"
DCAPURL=([32]="http://classis01.roma1.infn.it/pacman/packages/dcap/i686/libdcap.so" [64]="http://classis01.roma1.infn.it/pacman/packages/dcap/x86_64/libdcap.so")
PACBALLREPO="http://classis01.roma1.infn.it/pacballs"
OSGDQ2PATCH="http://classis01.roma1.infn.it/pacman/packages/dq2/OSG/dq2-patch.tar.gz"
ATLASLOGINPATCHURL="http://classis01.roma1.infn.it/pacman/packages/AtlasLogin"
ATLASSETUPPATCHURL="http://classis01.roma1.infn.it/pacman/packages/AtlasSetup/patches"
DQ2SETUPURL="http://classis01.roma1.infn.it/pacman/packages/DQ2Setup"
PCMODE="all"
MAXRELSETUPDEPTH=5

OPTS=`getopt -o a:d:D:fgG:H:i:k:l:m:M:oO:p:P:Qr:R:s:St:T:x:w:hcCfnNquv:V -l add-tags,autoconf:,cache,check,cleanup,clean-links,compiler-home:,cvmfs-install,debug,dest:,dbarea:,dbrelease:,dbrelease-cache:,dbrelease-clean,ddm-setup:,ddm-site:,ddm-verify,dir:,disk-free:,dump-tags:,extra-tag:,extra-pkg:,force-tags,goc-name:,grid-name:,kv-conf:,kv-disable:,kv-enable:,kv-keep,kv-no-auto,kvpost-tag:,grid-cache,host:,install:,install-compiler,kit-cache:,kv-cache:,kvpost,local-config:,logical:,logical-link:,manage:,min-install-size:,no-opt,no-tag,no-compat-patch,no-new-pacball,override-lock,package:,pacman-ver:,pretend-platform:,physical:,physical-link:,post-siteinfo,post-siteurl:,project:,project-opt:,project-type:,quiet,restore-backup,reinstall,reinstall-clean,relative-links,release-only,release-path:,pacball,pacball-dataset:,pacball-repo:,poolcond-copy,poolcond-mode:,poolcond-scandir,poolcond-topdir:,poolcond-pattern:,release-setup:,release-setup-level:,release-ver:,replicate,remove:,remove-snap:,remove-tags,rm-tags-on-fail,require-compiler,require-shfs,require-prj:,setenv:,set-frontier,setup-latest:,site-config:,site-type:,skip-local-config,snap:,snapdir:,snapname:,subcluster:,tag-file:,tag-mode:,tag-utility:,tags:,target:,temp-cache,test:,tthreads:,update,use-grid,vo:,validate,validation-exe:,xml:,create-dvd,write-dvd:,help,force,no-cache,no-version,query,stagein:,lfcHost:,inputGUIDs:,oldPrefix:,newPrefix: -- "$@"` 
if [ $? != 0 ] ; then
    echo "[ARGUMENTS] $@"
    echo "Terminating..."
    exit 1
fi
eval set -- "$OPTS"

while true ; do
    case "$1" in
        --autoconf|-a)         AUTOCONF="$2";shift 2;autoconfig;;
        --add-tags)            TAGACTION="add";shift;;
        --dump-tags)           DUMPTAGS="$2";shift 2;;
        --cache)               NOCACHE="no";shift;;
        --create-dvd|-c)       ACTION="mkiso";shift;;
        --cleanup|-C)          ACTION="cleanup";shift;;
        --clean-links)         CLEANLINKS="yes";shift;;
        --check)               ACTION="check";shift;;
        --compiler-home)       COMPILER_HOME="$2";shift 2;;
        --cvmfs-install)       CVMFSINSTALL="yes";shift;;
        --ddm-setup)           DDMSETUP="$2";shift 2;;
        --ddm-site)            DDMSITE="$2";shift 2;;
        --ddm-verify)          DDMVERIFY="yes";shift 2;;
        --debug)               DEBUG="yes";shift;;
        --disk-free|-D)        MINDF="$2";shift 2;;
        --dbarea)              DBAREA="$2";shift 2;;
        --dbrelease)           DBREL="$2";shift 2;;
        --dbrelease-cache)     DBRELCACHE="$2";shift 2;;
        --dbrelease-clean)     DBRELCLEAN="yes";shift;;
        --extra-tag)           EXTRATAG="$2";shift 2;;
        --extra-pkg)           EXTRAPKG="$2";shift 2;;
        --force-tags|-f)       FORCETAGS="yes";shift;;
        --goc-name)            GOCNAME="$2";shift 2;;
        --install-compiler)    INSTCOMPILER="yes";shift;;
        --grid-name|-G)        GRIDNAME="`echo $2 | tr a-z A-Z`";shift 2;;
        --kv-cache)            LCGCACHE="$2";shift 2;;
        --kv-conf)             KVCONFURL="$2";shift 2;;
        --kv-disable)          KVD="$2";shift 2;;
        --kv-enable)           KVE="$2";shift 2;;
        --kv-keep)             KVKEEP="y";shift;;
        --kv-no-auto)          KVNOAUTO="y";shift;;
        --kvpost)              T_POST="yes";shift;;
        --kvpost-tag)          KVPOSTTAG="$2";shift 2;;
        --validate|-V)         ACTION="validate";shift;;
        --force|-f)            PACMAN_OPTS="$PACMAN_OPTS -clear-lock";shift;;
        --override-lock)       PACMAN_OPTS="$PACMAN_OPTS -allow lock-override";shift;;
        --pretend-platform)    PACMAN_OPTS="$PACMAN_OPTS -pretend-platform:$2";shift 2;;
        --help|-h)             help;exit;;
        --host|-H)             TAGHOST="$2";shift 2;;
        --vo)                  TAGVO="$2";shift 2;;
        --install|-i)          ACTION="install";RELEASE="$2";shift 2;;
        --inputGUIDs)          INPUTGUIDS="$2";shift 2;;
        --manage|-M)           ACTION="manage";RELEASE="$2";shift 2;;
        --kit-cache|-k)        ATLAS="$2";shift 2;;
        --min-install-size)    MININSTALLSIZE="$2";shift 2;;
        --dest)                SWPATH="$2";shift 2;;
        --lfcHost)             LFCHOST="$2";shift 2;;
        --local-config)        LOCALCONF="$2";shift 2;;
        --logical|-l)          SWLOC="`echo $2 | sed 's;//*;/;g'`";shift 2;;
        --logical-link)        LOGLINK="`echo $2 | sed 's;//*;/;g'`";shift 2;;
        --no-opt)              NOOPT="yes";shift;;
        --no-tag)              NOTAG="yes";shift;;
        --no-cache|-n)         NOCACHE="yes";shift;;
        --no-version)          NOVERSION="yes";shift;;
        --no-compat-patch)     COMPATPATCH="";shift;;
        --no-new-pacball)      CREATE_PACBALL="n";shift;;
        --package)             PACKAGE="$2";shift 2;;
        --pacman-ver|-m)       PACMAN_VER="$2";shift 2;;
        --physical|-p)         RELLOC="`echo $2 | sed 's;//*;/;g'`";shift 2;;
        --physical-link)       PHYSLINK="`echo $2 | sed 's;//*;/;g'`";shift 2;;
        --poolcond-copy)       PFCCOPY="yes";shift;;
        --poolcond-mode)       PCMODE="`echo $2 | tr [A-Z] [a-z]`";shift 2;;
        --poolcond-pattern)    PCPATTERN="$2";shift 2;;
        --poolcond-scandir)    PCSCANDIR="yes";shift;;
        --poolcond-topdir)     PCTOPDIR="$2";shift 2;;
        --post-siteinfo)       POSTSITEINFO="yes";shift;;
        --post-siteurl)        POSTSITEURL="$2";shift 2;;
        --project|-P)          PRJNAME="$2";shift 2;;
        --project-opt|-O)      PRJOPT="$2";shift 2;;
        --project-type|-T)     PRJTYPE="`echo $2 | tr [A-Z] [a-z]`";shift 2;;
        --quiet|-Q)            QUIET="yes";shift;;
        --require-compiler)    REQCOMPILER="yes";shift;;
        --require-prj)         REQPRJNAME="$2";shift 2;;
        --restore-backup)      RESTOREBCK="yes";shift;;
        --use-grid|-g)         USEGRID="yes";shift;;
        --pacball)             USEPACBALL="yes";shift;;
        --pacball-repo)        PACBALLREPO="$2";shift 2;;
        --pacball-dataset)     PACBALLDATASET="$2";shift 2;;
        --reinstall)           REINSTALL="yes";shift;;
        --reinstall-clean)     REINSTALLCLEAN="yes";shift;;
        --relative-links)      RELLINKS="yes";shift;;
        --release-only|-o)     PACKOPT="rel";shift;;
        --release-path)        MAINRELPATH="$2";shift 2;;
        --release-setup)       RELSETPATH="$2";shift 2;;
        --release-setup-level) MAXRELSETUPDEPTH="$2";shift 2;;
        --release-ver|-v)      RELVER="$2";shift 2;;
        --remove|-r)           ACTION="remove";RELEASE="$2";shift 2;;
        --remove-snap|-R)      ACTION="remove-snap";RELEASE="$2";shift 2;;
        --remove-tags)         TAGACTION="remove";shift;;
        --rm-tags-on-fail)     RMTAGONFAIL="yes";shift;;
        --replicate)           GRIDREPLICA="yes";shift;;
        --require-shfs|-S)     REQSHAREDFS="yes";shift;;
        --setenv)              SETENV="$2";shift 2;;
        --set-frontier)        SETFRONTIER="y";shift;;
        --setup-latest)        PRESETUP="$2";shift 2;;
        --site-config)         SITECONF="$2";shift 2;;
        --site-type)           SITETYPE="$2";shift 2;;
        --skip-local-config)   SKIPLOCALCONF="yes";shift;;
        --snap|-s)             ACTION="snap";RELEASE="$2";shift 2;;
        --snapname)            SNAPNAME="$2";shift 2;;
        --snapdir)             SNAPDIR="$2";shift 2;;
        --stagein)             STAGEIN="$2";shift 2;;
        --subcluster)          TAGSCNAME="$2";shift 2;;
        --tag-file)            TAGFILE="$2";shift 2;;
        --tag-mode)            TAGMODE="$2";shift 2;;
        --tag-utility)         TAG_UTILITY="$2";shift 2;;
        --tags)                TAGNAME="$2";shift 2;;
        --target|-t)           ARCH="$2";shift 2;;
        --temp-cache)          TEMPCACHE="yes";shift;;
        --test)                ACTION="test";RELEASE="$2";shift 2;;
        --tthreads)            TESTTHR="$2";shift 2;;
        --update|-u)           UPDATE="yes";shift;;
        --dir|-d)              TOPDIR="$2";shift 2;;
        --query|-q)            ACTION="query";shift;;
        --write-dvd|-w)        ACTION="writeiso";ISOIMAGE="$2";shift 2;;
        --xml|-x)              XMLFILE="${2}";shift 2;;
        --validation-exe)      VALEXE="$2";shift 2;;
        --)                    shift;break;;
        \?)                    break;
        exit;;
    esac
done

# Complete the configuration
export T_POST
CATALOG_PATH="/grid/$TAGVO/install/lcg"
PRJTAGNAME="`echo $PRJNAME | sed 's#^Atlas##g' | tr [A-Z] [a-z]`"
PACMAN_OPTS="$PACMAN_OPTS -trust-all-caches -allow tar-overwrite -allow unsupported-platforms"
[ "`echo $MINDF | cut -d':' -f 1`" != "" ] && MINRELDF="`echo $MINDF | cut -d':' -f 1`"
[ "`echo $MINDF | cut -d':' -f 2`" != "" ] && MINSWDF="`echo $MINDF | cut -d':' -f 2`"
[ "`echo $MINDF | cut -d':' -f 3`" != "" ] && MINTDDF="`echo $MINDF | cut -d':' -f 3`"
[ "$TAGNAME" == "" ]  && TAGNAME="VO-atlas-${PRJTAGNAME}-${RELEASE}"
[ "$DDMSITE" == "auto" ] && unset DDMSITE

# Stage in files
if [ -n "$STAGEIN" ] ; then
    for STAGEURL in `echo $STAGEIN | sed 's/,/ /g'`; do
        wget --no-check-certificate $STAGEURL
    done
fi

# PoolCond pattern
PCSCHEMA="`echo $PCPATTERN | sed 's#\(http.*\)://\(.*\)#\1#'`"
if [ "$PCSCHEMA" == "http" -o "$PCSCHEMA" == "https" ] ; then
    wget -N -c $PCPATTERN
    PCSCHEMAFILE="`basename $PCPATTERN`"
    PCPATTERN="`cat $PCSCHEMAFILE 2> /dev/null`"
else
    PCPATTERN="`echo $PCPATTERN | sed 's/+/ /g'`"
fi

# Grid stuff
if [ "$USEGRID" == "yes" ] ; then
    CLOSESE="`edg-brokerinfo getCloseSEs 2>/dev/null| head -n 1 | awk '{ print $1}' | tr [A-Z] [a-z] | grep -v ^error`"
    [ "$CLOSESE" == "" ] && CLOSESE="`glite-brokerinfo getCloseSEs 2>/dev/null| head -n 1 | awk '{ print $1}' | tr [A-Z] [a-z] | grep -v ^error`"
    [ "$CLOSESE" != "" ] && msgOut INFO "Close SE: $CLOSESE" || msgOut WARNING "No close SE found"
fi
if [ "$XMLFILE" != "" ] ; then
    [ "`dirname $XMLFILE`" == "." ] && XMLFILE="$PWD/`basename $XMLFILE`"
    xml open
fi
# Workaround for VOMS proxies in OSG
[ "$GRIDNAME" == "OSG" ] && export VOMS_PROXY_INFO_DONT_VERIFY_AC=none

msgOut INFO "Initial umask: `umask`"
case `whoami` in
    usatlas*) msgOut INFO "This is an OSG site with static accounts. Setting umask to g-w,o-w,a+rx"
        umask g-w,o-w,a+rx
        ;;
    *[0-9])
        msgOut INFO "This site is configured for SGM pool accounts. Setting umask to g+w,o-w,a+rx"
        umask g+w,o-w,a+rx
        ;;
    *) msgOut INFO "This site is configured for SGM static accounts. Setting umask to g-w,o-w,a+rx"
        umask g-w,o-w,a+rx
        ;;
esac
msgOut INFO "Using umask `umask`"


INSTALLER_HOME="`dirname $0`"
if [ "$XMLFILE" != "" ] ; then
    [ "$XMLFILE" == "`basename $XMLFILE`" ] && XMLFILE=$INSTALLER_HOME/$XMLFILE
fi
[ "$INSTALLER_HOME" == "." ] && INSTALLER_HOME="$PWD"
[ "$TOPDIR" == "" ] && TOPDIR="${PWD}"
[ "$ARCH"   == "" ] && ARCH="rh73"
if [ "$ACTION" == "" ] ; then
    msgOut ERROR "No action specified. Type -h for help."
    [ "$XMLFILE" != "" ] && xml close
    exit -1
fi

# Scratch directories
if [ -n "$OSG_WN_TMP" -a -d "$OSG_WN_TMP" ] ; then
    TOPDIR="$OSG_WN_TMP/tmp.install.$$"
    NEWTOPDIR="$TOPDIR"
    msgOut INFO "Using scratch directory $TOPDIR"
fi

[ ! -d $TOPDIR ] && mkdir -p $TOPDIR
\find $TOPDIR -maxdepth 1 -type d ! -perm -a+rx -exec chmod a+rx {} \;
export PATH=.:$INSTALLER_HOME:$PATH
[ "$VO_ATLAS_SW_DIR" == "" ] && export VO_ATLAS_SW_DIR=$TOPDIR
export PATH=$VO_ATLAS_SW_DIR:$PATH
[ "$SITECONF" == "" ] && SITECONF=$VO_ATLAS_SW_DIR/AtlasSiteConfig.sh
[ "$SITESETUP" == "" ] && SITESETUP=$RELLOC/AtlasSite/AtlasSiteSetup
[ -s $PWD/lcg-tags ] && chmod +x $PWD/lcg-tags
[ "$LCGCACHE" == "" ] && LCGCACHE="http://classis01.roma1.infn.it/pacman/cache"
if [ "$ACTION" == "genpfc" ] ; then
    [ "$PCDIR" == "" ] && PCDIR="$VO_ATLAS_SW_DIR/local/conditions"
    [ "$PCPATTERN" == "" ] && PCPATTERN="comcond* cmccond* cond09* cond08* oflcond.*"
fi
[ -z "$DBRELCACHE" ] && DBRELCACHE="http://atlas.web.cern.ch/Atlas/GROUPS/DATABASE/pacman4/DBRelease"
DBRELPKG="DBRelease-$DBREL"
if [ "$ATLAS" == "" ] ; then
  if [ "$PRJNAME" == "release" -o "$PRJNAME" == "AtlasRelease" ] ; then
    ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
  else
    if [ "$PRJTYPE" == "p1nightly" ] ; then
      ATLAS="$TOPDIR/AtlasPoint1.caches"
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel1/pcache/cache" > $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_0/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_1/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_2/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_3/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_4/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_5/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/pcache1/rel_6/cache" >> $ATLAS
      echo "http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/projects/cache" >> $ATLAS
    elif [ "$PRJTYPE" == "bugfix" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/bugfix/cache"
    elif [ "$PRJTYPE" == "dev" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/buildDirectory/kitrel/nightlies/dev/cache"
    elif [ "$PRJTYPE" == "patch" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/Production/cache"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "analysis" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/Analysis/cache"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasProduction"
    elif [ "$PRJTYPE" == "p1patch" -o "$PRJTYPE" == "t0patch" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/Production/cache"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "eventview" ] ; then
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/PAT/EventView"
      [ "$REQPRJNAME" == "" ] && REQPRJNAME="AtlasOffline"
    elif [ "$PRJTYPE" == "tdaq" ] ; then
        case $ARCH in
            *_slc6_*) ATLAS="https://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/yum/tdaq/slc6/";;
            *) ATLAS="http://atlas-tdaq-sw.web.cern.ch/atlas-tdaq-sw/download/apt/tdaq-new/tdaq/";;
        esac
    elif [ "$PRJTYPE" == "ext" ] ; then
      ATLAS="http://classis01.roma1.infn.it/pacman/cache"
    elif [ "$PRJTYPE" == "dbrelease" ] ; then
      ATLAS="$DBRELCACHE"
    else
      ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/kitsDirectory/projects/cache"
    fi
  fi
fi
PACMAN_URL="http://physics.bu.edu/~youssef/Pacman/sample_cache/tarballs"
PACMAN_DIR=${INSTALLER_HOME}/pacman-${PACMAN_VER}
PACMAN_TAR=${PACMAN_DIR}.tar.gz
[ "$SNAPDIR" == "" ] && SNAPDIR=${TOPDIR}/snapshots
# Define the snapshot name
if [ "$SNAPNAME" == "" ] ; then
  SNAPNAME="atlas-`echo ${PRJNAME} | tr [A-Z] [a-z] | sed 's#^atlas##g'``echo -${PRJTYPE} | tr [A-Z] [a-z] | sed 's#-release##g'`-${RELEASE}-${RELVER}"
  [ "$ARCH" != "" ] && SNAPNAME="${SNAPNAME}-`echo ${ARCH} | sed -e 's#^_##g'`"
  [ "$PRJOPT" != "" ] && SNAPNAME="${SNAPNAME}-${PRJOPT}"
  msgOut INFO "Self-generated snapshot name: $SNAPNAME"
else
  SNAPNAME="`echo $SNAPNAME | sed -e 's/.tar.gz//g' -e 's/.tgz//g'`"
  msgOut INFO "Requested snapshot name: $SNAPNAME"
fi

[ -s ${INSTALLER_HOME}/`basename ${SNAPDIR}`/${SNAPNAME} ] \
                      && SNAPDIR="${INSTALLER_HOME}/`basename ${SNAPDIR}`"

KV=KitValidation
if [ "$PACKAGE" != "" ] ; then
  ARC="`uname -m`"
  GCC=gcc${ARCH}
  ATLASRELEASE="${PACKAGE}"
elif [ "$ARCH" == "rh73_old" ] ; then
  GCC=gcc
  ATLASRELEASE="${RELEASE}/AtlasRelease-opt"
elif [ "$ARCH" == "slc3" ] ; then
  GCC=gcc-slc3
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
  ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
elif [ "$ARCH" == "slc3_ia32" ] ; then
  GCC=gcc-slc3
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
  ATLAS="http://atlas-computing.web.cern.ch/atlas-computing/links/monolith/slc3/cache"
elif [ "`echo $ARCH | grep ^_`" != "" -a "$PRJNAME" != "release" -a "$PRJNAME" != "AtlasRelease" ] ; then
  ARC="`uname -m`"
  GCC=gcc${ARCH}
  if [ "$PRJTYPE" == "tdaq" ] ; then
    REL="`echo ${RELEASE} | cut -d@ -f 1 | awk -F. 'BEGIN{str=""}{for(i=1;i<=NF;i++) {if (length(str)>0) str=sprintf("%s-%02d",str,$i); else str=sprintf("%02d",$i)}}END{print str}'`"
    ATLASRELEASE="${PRJNAME}-${REL}"
  else
    REL="`echo ${RELEASE} | sed "s#\.#_#g"`"
    [ "$PRJTYPE" != "ext" ] && ARCH1="`echo ${ARCH} | sed -e 's/43[5-9]$/43/' -e 's/46[0-9]$/46/'`" || ARCH1="$ARCH"
    ATLASRELEASE="${PRJNAME}_${REL}${ARCH1}"
    [ "$PRJOPT" != "" -a "$NOOPT" != "yes" ] && ATLASRELEASE="${ATLASRELEASE}_${PRJOPT}"
  fi
elif [ "$ARCH" == "noarch" ] ; then
  ATLASRELEASE="${PRJNAME}"
  [ "$NOVERSION" != "yes" ] && ATLASRELEASE="${ATLASRELEASE}-${RELEASE}" || ATLASRELEASE="${ATLASRELEASE}|version('${RELEASE}')"
else
  GCC=gcc-${ARCH}
  ATLASRELEASE="${RELEASE}/AtlasRelease-${ARCH}-opt"
fi

# Initialize the return code
let rc=0

[ "$DEBUG" == "yes" ] && msgOut DEBUG "Debug output enabled"

# Show the site info
showSiteInfo
if [ "$DEBUG" == "yes" ] ; then
    msgOut DEBUG "PATH=${PATH}"
    msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
    msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
fi

# Setup pacman
cd "${TOPDIR}"
if [ "$ACTION" == "validate" -o "$ACTION" == "install" -o "$ACTION" == "test" -o "$ACTION" == "remove" -o "$ACTION" == "snap" ] ; then
    if [ "$ACTION" == "validate" -o "$ACTION" == "install" ] ; then
        [ "$USEPACBALL" == "yes" ] && SKIPSETUP="yes"
    fi
    [ "$PRJTYPE" == "poolcond" ] && SKIPSETUP="yes"
    # Skip the pacman setup if we're installing and using pacballs
    if [ "$SKIPSETUP" == "" -a "`which pacman 2>/dev/null`" == "" ] ; then    
        setupPacman
        let rc=$rc+$?
        if [ $rc -ne 0 ] ; then
            msgOut ERROR "Cannot setup pacman"
            [ "$XMLFILE" != "" ] && xml close
            exit $rc
        fi
        if [ "$DEBUG" == "yes" ] ; then
            msgOut DEBUG "PATH=${PATH}"
            msgOut DEBUG "LD_LIBRARY_PATH=${LD_LIBRARY_PATH}"
            msgOut DEBUG "PYTHONPATH=${PYTHONPATH}"
        fi
    else
        msgOut INFO "I will not download pacman since we are using pacballs or pacman has been disabled."
    fi
fi

# Define the installation directories
[ "$DEBUG" == "yes" ] && msgOut DEBUG "SWLOC [1] =$SWLOC"
if [ "$SWLOC" == ""  ] ; then
    [ "$RELLOC" != "" ] && SWLOC="$RELLOC" \
                        || SWLOC="${TOPDIR}/software/${RELEASE}"
fi
[ "$RELLOC" == "" ] && RELLOC=${TOPDIR}/releases

# Handle multiple logical locations
FULLSWLOC="$SWLOC"
for TMPLOC in `echo $FULLSWLOC | sed 's/,/ /g'`; do
    SWLOC="$TMPLOC"
    [ -d "$TMPLOC" ] && break
done

# Reset the logical install path if a logical link is found and if running on CVMFS
[ -n "$LOGLINK" -a -d "$LOGLINK" -a "`getFSType $LOGLINK`" == "cvmfs" ] && SWLOC=$LOGLINK

# Reset the physical install path if running on CVMFS
[ -d $SWLOC -a "`getFSType $SWLOC`" == "cvmfs" ] && RELLOC=$SWLOC

[ ! -d "$RELLOC" -a -d ${TOPDIR}/releases/`basename $RELLOC` ] && RELLOC=${TOPDIR}/releases/`basename $RELLOC`
if [ "$ACTION" == "install" -o "$ACTION" == "validate" ] ; then
    RLDIR=$RELLOC
    while [ ! -d $RLDIR ] ; do RLDIR="`dirname $RLDIR`"; done
    SWAREAFS="`getFSType $RLDIR`"
    if [ "$SWAREAFS" != "cvmfs" ] ; then
        prepareInstallDirs
        let rc=$rc+$?
        if [ $rc -ne 0 ] ; then
            msgOut ERROR "Cannot create the installation directories. The installer will now exit."
            [ "$XMLFILE" != "" ] && xml close
            exit $rc
        fi
    fi
fi

# Save the environment
export ENVSTART="/tmp/sw-mgr-envstart.tmp.$$"
msgOut INFO "Saving the installation environment in $ENVSTART"
/usr/bin/env | grep '=' | cut -d'=' -f 1 | egrep -v '^_$|^\s|^	|^$' | while read var; do echo "$var='`/usr/bin/printenv $var`'"; done > $ENVSTART
[ "$LD_LIBRARY_PATH" == "" ] && echo "unset LD_LIBRARY_PATH" >> $ENVSTART
[ "$PYTHONPATH" == "" ] && echo "unset PYTHONPATH" >> $ENVSTART

# Perform the pre-setup, if required
if [ "$RELSETPATH" != "" -o "$PRESETUP" != "" ] ; then
    [ "$RELSETPATH" != "" ] && RSP="$RELSETPATH"
    [ "$PRESETUP"   != "" ] && RSP="$PRESETUP"
    msgOut INFO "Searching for ATLAS sw releases in ${RSP} - this may take some time..."
    if [ "`isAFSpath $RSP`" == "yes" ] ; then
      RELLIST=(`find $RSP -noleaf -maxdepth $MAXRELSETUPDEPTH -path "*/AtlasOffline/*/InstallArea/*slc*gcc*" 2>/dev/null | awk -F '/' '{print $(NF-2)","$0;}' | sort | cut -d',' -f 2-`)
    else
      RELLIST=(`find $RSP -maxdepth $MAXRELSETUPDEPTH -path "*/AtlasOffline/*/InstallArea/*slc*gcc*" 2>/dev/null | awk -F '/' '{print $(NF-2)","$0;}' | sort | cut -d',' -f 2-`)
    fi
    MAXREL=$((${#RELLIST[@]}-1))
    msgOut INFO "${#RELLIST[@]} release(s) found in $RSP"
    declare RELSETUP
    declare RELPYTHON
    for r in `seq 0 $MAXREL`; do
        RELDATA=(`echo ${RELLIST[$r]} | sed 's#\(.*\)/AtlasOffline/\([0-9\.]*\)/InstallArea/\([^-]*\)-\(slc[0-9]\)-\(gcc[0-9]*\)-.*#\1 \2 \3 \4 \5#'`)
        # Main release version
        MAINRELVER="`echo ${RELDATA[1]} | awk -F "." '{for (i=1;i<=3;i++) ver=sprintf("%s%02d",ver,$i)}END{print int(ver)}'`"
        if [ -s "${RELDATA[0]}/cmtsite/asetup.sh" -a $MAINRELVER -ge 160000 ] ; then
            RELSETUPLIST[$r]="source ${RELDATA[0]}/cmtsite/asetup.sh AtlasOffline ${RELDATA[1]} runtime ${RELDATA[3]} ${RELDATA[4]}"
        else
            RELSETUPLIST[$r]="source ${RELDATA[0]}/cmtsite/setup.sh -tag=AtlasOffline,${RELDATA[1]},runtime,${RELDATA[3]},${RELDATA[4]}"
        fi
        [ "${RELDATA[2]}" == "i686" ] && RELSETUPLIST[$r]="${RELSETUPLIST[$r]},32" || RELSETUPLIST[$r]="${RELSETUPLIST[$r]},64"
        RELPYTHON[$r]="`find ${RELDATA[0]}/sw/lcg/external/Python -type d -name bin -exec dirname {} \; 2>/dev/null | sort | tail -n 1`"
    done
    if [ $MAXREL -ge 0 ] ; then
        RELSETUP=${RELSETUPLIST[$MAXREL]}
        if [ "$PRESETUP" != "" ] ; then
            if [ -s "$RELSETUP" ] ; then
                msgOut INFO "Setting up the latest release with $RELSETUP"
                msgOut INFO "${RELSETUP}"
                eval ${RELSETUP}
            else
                msgOut WARNING "Cannot setup a suitable release from $RSP"
            fi
        fi
    else
        msgOut WARNING "No ATLAS releases found in $RSP !"
    fi
fi

# Execute the actions
RLDIR=$RELLOC
while [ ! -d $RLDIR ] ; do RLDIR="`dirname $RLDIR`"; done
SWAREAFS="`getFSType $RLDIR`"
msgOut INFO "Running on $SWAREAFS filesystem"

# Print out the ATLAS local area location for CVMFS
if [ "$SWAREAFS" == "cvmfs" ] ; then
    if [ -n "$ATLAS_LOCAL_AREA" ] ; then
        msgOut INFO "ATLAS_LOCAL_AREA is $ATLAS_LOCAL_AREA"
    else
        msgOut INFO "No ATLAS_LOCAL_AREA defined"
    fi
    if [ "$POSTSITEINFO" == "yes" -a "$TAGHOST" != "" ] ; then
        postSiteInfo
    fi 

fi

if [ "$SWAREAFS" == "cvmfs" -a -z "$DBAREA" ] ; then
    if [ -n "$VO_ATLAS_SW_DIR" -a -d "$VO_ATLAS_SW_DIR/database" ] ; then
        DBAREA="$VO_ATLAS_SW_DIR/database"
    elif [ -n "$OSG_APP" -a -d "$OSG_APP/atlas_app/atlas_rel/database" ] ; then
        DBAREA="$OSG_APP/atlas_app/atlas_rel/database"
    else
        msgOut WARNING "Cannot determine the DB area while running on cvmfs"
    fi
fi

if [ "$ACTION" == "install" -o "$ACTION" == "validate" ] ; then
    if [ "$SWAREAFS" != "cvmfs" ] ; then
        if [ "$REINSTALL" == "yes" ] ; then
            RELLOCBASE="$RELLOC"
            RELLOCINDX="`\ls -d ${RELLOC}.r* 2> /dev/null | wc -l`"
            let RELLOCINDX=$RELLOCINDX+1
            RELLOC="${RELLOC}.r${RELLOCINDX}"
            msgOut INFO "Re-installation requested. Installing in $RELLOC."
        elif [ "$REINSTALLCLEAN" == "yes" ] ; then
                msgOut INFO "Re-installation cleanup requested. Removing the old stuff."
                remove
        fi
        if [ "$REINSTALL" == "yes" -o "$REINSTALLCLEAN" == "yes" ] ; then
            prepareInstallDirs
            let rc=$rc+$?
            if [ $rc -ne 0 ] ; then
                msgOut ERROR "Cannot create the installation directories. The installer will now exit."
                [ "$XMLFILE" != "" ] && xml close
                exit $rc
            fi
        else
            msgOut INFO "Starting the normal installation phase."
        fi
    fi

    # Check the site parameters for the installation if we are not using CVMFS
    if [ "$SWAREAFS" != "cvmfs" ] ; then
        checkSite
        let rc=$rc+$?
    fi

    # Install only if everything is OK
    if [ $rc -eq 0 ] ; then
        if [ "$SWAREAFS" != "cvmfs" ] ; then
            install
            let rc=$rc+$?
        elif [ "$SWAREAFS" == "cvmfs" -a -n "$ATLAS_LOCAL_AREA" ] ; then
            if [ "$PRJTYPE" == "poolcond" ] ; then
                [ -s "${ATLAS_LOCAL_AREA}/setup.sh.local" ] && ATLAS_LOCAL_POOLCOND="`. ${ATLAS_LOCAL_AREA}/setup.sh.local > /dev/null;echo $ATLAS_LOCAL_POOLCOND | tr A-Z a-z`"
                if [ -z "$ATLAS_LOCAL_POOLCOND" ] ; then
                    msgOut INFO "Installing overrides to $PRJTYPE for CVMFS"
                    LOCALCONF="$ATLAS_LOCAL_AREA"
                    setLocalConfig
                    let rc=$rc+$?
                else
                    msgOut INFO "Installing a local PFC copy since ATLAS_LOCAL_POOLCOND is set, skipping CVMFS setup"
                    RELLOC="${ATLAS_LOCAL_AREA}/conditions/poolcond"
                    SWLOC="$RELLOC"
                    LOCALCONF="$ATLAS_LOCAL_AREA"
                    SITECONF="${ATLAS_LOCAL_AREA}/AtlasSiteConfig.sh"
                    install
                    let rc=$rc+$?
                fi
            elif [ "$PRJTYPE" == "ext" -a "$PRJNAME" == "DQ2Clients" -a -n "$SETENV" ] ; then
                ATLLOCAREA="`getRWpath ${ATLAS_LOCAL_AREA}`"
                msgOut INFO "Installing overrides to $PRJNAME for CVMFS in $ATLLOCAREA/setup-dq2.sh"
                msgOut INFO "Overrides are: $SETENV"
                echo "$SETENV" | tr ',' '\n' | sed 's/^/export /g' > $ATLLOCAREA/setup-dq2.sh
                let rc=$rc+$?
            else
                msgOut INFO "Skipping the installation because $PRJTYPE $PRJNAME does not need to install in CVMFS"
            fi
        else
            msgOut INFO "Skipping the installation since we are on cvmfs filesystem and/or no local override area was specified"
        fi
        if [ "$ACTION" == "validate" ] ; then
            if [ $rc -eq 0 ] ; then
                if [ "$SWAREAFS" == "cvmfs" -a "$PRJTYPE" == "poolcond" ] ; then
                    msgOut INFO "Skipping validation of $PRJTYPE because we are in CVMFS"
                else
                    validate
                    let rc=$rc+$?
                fi
            else
                msgOut INFO "Skipping validation due to previous errors"
            fi
        fi
        if [ $rc -eq 0 -o "$FORCETAGS" == "yes" ] ; then
            if [ "$TAGACTION" == "add" ] ; then
                addTag
                let tagrc=$?
                [ $tagrc -ne 0 ] && msgOut ERROR "Cannot add tags"
                let rc=$rc+$tagrc
            fi
        elif [ $rc -ne 0 -a "$RMTAGONFAIL" == "yes" ] ; then
            removeTag
            let tagrc=$?
            [ $tagrc -ne 0 ] && msgOut ERROR "Cannot remove tags"
            let rc=$rc+$tagrc
        fi
    fi
elif [ "$ACTION" == "test" ] ; then
    validate
    let rc=$rc+$?
    if [ "$NOTAG" != "yes" ] ; then
        if [ $rc -eq 0 ] ; then
            addTag
        else
            if [ "$TAGHOST" != "" ] ; then
                SWAREAINFO="`getSWarea`"
                #SHARED_INSTALL="`wget -qO --no-check-certificate - --post-data="swarea=${SWAREAINFO}&rel=${RELEASE}&status=installed" ${POSTRELURL}`"
                SHARED_INSTALL="`curl --connect-timeout 300 --insecure -s -S --data "swarea=${SWAREAINFO}&rel=${RELEASE}&status=installed" ${POSTRELURL}`"
                if [ $? -eq 0 ] ; then
                    SHARED_INSTALL="`echo $SHARED_INSTALL | awk '{print $1}' | sed "s#${RELEASE}#yes#g"`"
                    if [ "$SHARED_INSTALL" == "yes" ] ; then
                        msgOut WARNING "Will not remove the tag from the dump file because this sw area (${SWAREAINFO}) is shared with other installed nodes"
                        unset DUMPTAGS
                    else
                        msgOut INFO "No other nodes are sharing this installation (${SWAREAINFO}), will remove the tag from the dump file"
                    fi
                else
                    msgOut WARNING "Cannot contact the LJSFi release info service. Will not remove the tag from the dump file"
                    unset DUMPTAGS
                fi
                removeTag
            else
                msgOut WARNING "No host to tag"
            fi
        fi
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
        let rc=$rc+$tagrc
    fi
elif [ "$ACTION" == "remove" ] ; then
    if [ "$TAGACTION" == "remove" ] ; then
        removeTag
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot remove tags"
        let rc=$rc+$tagrc
    fi
    if [ $rc -eq 0 ] ; then
        if [ "$SWAREAFS" != "cvmfs" ] ; then
            remove
            let rc=$rc+$?
        else
            msgOut INFO "Skipping the removal phase since we are using cvmfs"
        fi
    else
        msgOut ERROR "Skipping software removal due to previous problems."
    fi
elif [ "$ACTION" == "manage" ] ; then
    if [ "$TAGACTION" == "add" ] ; then
        addTag
    elif [ "$TAGACTION" == "remove" ] ; then
        removeTag
    fi
    let tagrc=$?
    [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
    let rc=$rc+$tagrc
elif [ "$ACTION" == "check" ] ; then
    checkSite
    let rc=$rc+$?
elif [ "$ACTION" == "remove-snap" ] ; then
    rm -f $SNAPDIR/${SNAPNAME}
    let rc=$rc+$?
elif [ "$ACTION" == "snap" ] ; then
    if [ "$USEPACBALL" != "yes" ] ; then
        snap "$SNAPDIR" "${SNAPNAME}"
    else
        pacball "$SNAPDIR" "${SNAPNAME}"
    fi
    let rc=$rc+$?
elif [ "$ACTION" == "query" ] ; then
    query
    let rc=$rc+$?
elif [ "$ACTION" == "cleanup" ] ; then
    if [ "$SWAREAFS" != "cvmfs" ] ; then
        cleanup
        let rc=$rc+$?
    else
        msgOut INFO "Skipping the cleanup phase since we are using cvmfs"
    fi
    if [ $rc -eq 0 ] ; then
        if [ "$TAGACTION" == "add" ] ; then
            addTag
        elif [ "$TAGACTION" == "remove" ] ; then
            removeTag
        fi
        let tagrc=$?
        [ $tagrc -ne 0 ] && msgOut ERROR "Cannot manage tags"
        let rc=$rc+$tagrc
    fi
elif [ "$ACTION" == "mkiso" ] ; then
    mkiso "atlas-kit-DVD-`date +%Y%m%d`.iso" "Atlas_`query -quiet`" "${USER}" "${TOPDIR}/sw-mgr ${PACMAN_DIR} ${TOPDIR}/patches ${SNAPDIR}"
    let rc=$rc+$?
elif [ "$ACTION" == "writeiso" ] ; then
    writeDVD "${ISOIMAGE}"
    let rc=$rc+$?
fi

cd ${INSTALLER_HOME}

# Clean up other files
if [ -f $ENVSTART ] ; then
    msgOut INFO  "Removing temporary environment file $ENVSTART"
    rm -fr $ENVSTART
fi
if [ -n "$NEWTOPDIR" -a -d "$NEWTOPDIR" -a "$NEWTOPDIR" != "$INSTALLER_HOME" ] ; then
    msgOut INFO  "Removing scratch directory $NEWTOPDIR"
    rm -fr $NEWTOPDIR
fi

# Exit the installer
msgOut EXIT  "$rc"
if [ $rc -eq 0 ] ; then
    msgOut INFO  "Processing OK"
else
    msgOut ERROR "Processing FAILED"
fi

# Close the xml file
[ "$XMLFILE" != "" ] && xml close

# Exit with the appropriate return code
exit $rc
